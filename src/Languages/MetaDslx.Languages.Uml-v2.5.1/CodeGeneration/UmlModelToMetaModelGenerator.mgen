namespace MetaDslx.Languages.Uml.CodeGeneration
generator UmlModelToMetaModelGenerator

using MetaDslx.Modeling;
using MetaDslx.Languages.Uml.MetaModel;
using System.Collections.Immutable;
using System.Linq;
using Roslyn.Utilities;

template Generate()
using MetaDslx.Modeling;
using System;
using System.Collections.Generic;
using System.Data;
using System.Text;

namespace [Namespace]
{
    ["["]MetaModel([Uri]="http://www.omg.org/spec/UML/", Prefix="[Prefix]")["]"]
	public partial interface [ModelName]
	{
	}

	[foreach (var pt in Objects.OfType<PrimitiveType>())]
    [GeneratePrimitiveType(pt)]

	[end foreach]
	[foreach (var enm in Objects.OfType<Enumeration>())]
    [GenerateEnum(enm)]

	[end foreach]
	[foreach (var cls in Objects.OfType<Class>())]
    [GenerateClass(cls)]

	[end foreach]
}
end template

template GeneratePrimitiveType(PrimitiveType pt)
[GenerateComment(pt)]
const PrimitiveType [pt.Name];
end template

template GenerateEnum(Enumeration enm)
[GenerateComment(enm)]
public enum [enm.Name]
{
	[foreach (var lit in enm.OwnedLiteral) separator ","]
    [GenerateComment(lit)]
    [lit.Name.ToPascalCase()][@skip-line-end]
	[end foreach]
}
end template

template GenerateClass(Class cls)
[GenerateComment(cls)]
[cls.IsAbstract ? "[MetaClass(IsAbstract = true)]" : "[MetaClass]"]
public partial interface [cls.Name][GenerateBaseClasses(cls)]
{
	[foreach (var prop in cls.OwnedAttribute)]
	[GenerateProperty(prop)]

	[end foreach]
	[foreach (var op in cls.OwnedOperation)]
	[GenerateOperation(op)]

	[end foreach]
}
end template

template GenerateBaseClasses(Class cls)
[string sep = " : "]
[foreach (var gen in cls.Generalization.Select(g => g.General))][sep][gen.Name][sep = ", "][end foreach]
end template

template GenerateProperty(Property prop)
[GenerateComment(prop)]
[if (prop.Aggregation == AggregationKind.Composite)]
["["]Containment["]"]
[end if]
[if (prop.IsDerivedUnion)]
["["]DerivedUnion["]"]
[else if (prop.IsDerived)]
["["]Derived["]"]
[end if]
[if (IsCollection(prop) && !prop.IsUnique)]
["["]NonUnique["]"]
[end if]
[if (IsCollection(prop) && !prop.IsOrdered)]
["["]Unordered["]"]
[end if]
[if (prop.IsReadOnly)]
["["]ReadOnly["]"]
[end if]
[GenerateOpposite(prop)]
[GenerateRedefines(prop)]
[GenerateSubsets(prop)]
[if (prop.DefaultValue != null)]
["["]DefaultValue([GenerateDefaultValue(prop)])["]"]
[end if]
[if (prop.IsDerived && !prop.IsDerivedUnion)]
public [GenerateType(prop, prop.Type)] [prop.Name.ToPascalCase()]
{ 
	get
	{
		throw new NotImplementedException();
	}
}
[else]
[GenerateType(prop, prop.Type)] [prop.Name.ToPascalCase()] { get;[if (!prop.IsReadOnly && !IsCollection(prop))] set;[end if] }
[end if]
end template

template GenerateType(MultiplicityElement me, MetaDslx.Languages.Uml.MetaModel.Type t)
[IsCollection(me) ? "IList<" : ""][GeneratePrimitiveType(t)][IsCollection(me) ? ">" : ""]
end template

template GenerateRedefines(Property prop)
[foreach (var rprop in prop.RedefinedProperty)]
	[if (rprop.Class != null)]
["["]Redefines(typeof([rprop.Class.Name]), "[rprop.Name.ToPascalCase()]")["]"]
	[end if]
[end foreach]
end template

template GenerateSubsets(Property prop)
[foreach (var rprop in prop.SubsettedProperty)]
	[if (rprop.Class != null)]
["["]Subsets(typeof([rprop.Class.Name]), "[rprop.Name.ToPascalCase()]")["]"]
	[end if]
[end foreach]
end template

template GenerateOpposite(Property prop)
[Property opposite = GetOpposite(prop)]
[if (opposite != null && opposite.Class != null)]
["["]Opposite(typeof([opposite.Class.Name]), "[opposite.Name.ToPascalCase()]")["]"]
[end if]
end template

template GenerateOperation(Operation op)
[var nonPropertyOperations = op.Class.OwnedAttribute.Where(prop => op.Name == prop.Name && prop.IsDerived && !prop.IsDerivedUnion)]
[if (nonPropertyOperations.Any())]
[GenerateComment(op)]
public [GenerateReturnType(op)] [op.Name.ToPascalCase()]([GenerateParams(op)])
{
	throw new NotImplementedException();
}
[end if]
end template

template GenerateReturnType(Operation op)
[var returnParam = op.OwnedParameter.Where(param => param.Direction == ParameterDirectionKind.Return).FirstOrDefault()]
[if (returnParam != null)][GenerateType(returnParam, returnParam.Type)][else]void[end if]
end template

template GenerateParams(Operation op)
[var incomingParams = op.OwnedParameter.Where(param => param.Direction != ParameterDirectionKind.Return)]
[foreach (var param in incomingParams) separator ", "][GenerateType(param, param.Type)] [param.Name][end foreach]
end template

template GenerateComment(Element elem)
[var comments = elem.OwnedComment.Where(comm => !string.IsNullOrWhiteSpace(comm.Body))]
[if (comments.Any())]
/// <summary>
	[foreach (var comm in comments)]
		[foreach (var line in CommentLines(comm.Body, true))]
/// [line]
		[end foreach]
	[end foreach]
/// </summary>
	[if (elem is Operation op)]
		[foreach (var param in op.OwnedParameter)]
/// <param name="[param.Name]">
			[foreach (var comm in param.OwnedComment.Where(comm => !string.IsNullOrWhiteSpace(comm.Body)))]
				[foreach (var line in CommentLines(comm.Body, true))]
/// [line]
				[end foreach]
			[end foreach]
/// </param>
		[end foreach]
	[end if]
[end if]
	[if (elem is Operation)]
[GenerateSpecification((Operation)elem)]
	[else if (elem is Property)]
		[var prop = (Property)elem]
		[if (prop.IsDerived && !prop.IsDerivedUnion)]
			[foreach (var op in prop.Class.OwnedOperation.Where(op => op.Name == prop.Name))]
[GenerateSpecification(op)]
			[end foreach]
		[end if]
	[end if]
end template

//->spec:Specification->expr:typeof(OpaqueExpression)
template GenerateSpecification(Namespace ns)
	[foreach (var rule in ns.OwnedRule)]
		[foreach (var comm in rule.OwnedComment.Where(comm => !string.IsNullOrWhiteSpace(comm.Body)))]
/// <para>
			[foreach (var line in CommentLines(comm.Body, true))]
/// [line]
			[end foreach]
/// </para>
		[end foreach]
// [rule.Name]:
		[if (rule.Specification is OpaqueExpression expr)]
			[foreach (var body in expr.Body)]
				[foreach (var line in CommentLines(body, false))]
//     [line]
				[end foreach]
			[end foreach]
		[end if]
	[end foreach]
end template
