namespace MetaDslx.Languages.Uml.CodeGeneration
generator UmlModelToMetaModelGenerator

using MetaDslx.Modeling;
using MetaDslx.Languages.Uml.MetaModel;
using System.Collections.Immutable;
using System.Linq;
using Roslyn.Utilities;

template GenerateInterface()
using MetaDslx.Modeling;
using System;
using System.Collections.Generic;
using System.Data;
using System.Text;

namespace [Namespace]
{
    ["["]MetaModel(Uri="[Uri]", Prefix="[Prefix]")["]"]
    public partial interface [ModelName]
    {
    }

    [foreach (var enm in Objects.OfType<Enumeration>())]
    [GenerateEnum(enm)]

    [end foreach]
    [foreach (var cls in Objects.OfType<Class>())]
    [GenerateClass(GetUmlClass(cls), false)]

    [end foreach]
}
end template

template GenerateImplementation()
using MetaDslx.Modeling;
using System;
using System.Collections.Generic;
using System.Data;
using System.Text;

namespace MetaDslx.Languages.Uml.MetaModel
{
    [foreach (var cls in Objects.OfType<Class>())]
    [GenerateClass(GetUmlClass(cls), true)]

    [end foreach]
}
end template

template GenerateEnum(Enumeration enm)
[GenerateComment(enm)]
public enum [enm.Name]
{
    [foreach (var lit in enm.OwnedLiteral) $separator ","]
    [GenerateComment(lit)]
    [lit.Name.ToPascalCase()][$skip-line-end]
    [end foreach]
}
end template

template GenerateClass(UmlClass ucls, bool implementation)
    [var cls = ucls.Class]
    [if (!implementation)]
[GenerateComment(cls)]
[cls.IsAbstract ? "[MetaClass(IsAbstract = true)]" : "[MetaClass]"]
public partial interface [cls.Name][GenerateBaseClasses(cls)]
    [else]
public partial interface [cls.Name]
    [end if]
{
    [foreach (var uprop in ucls.Attributes)]
    [GenerateProperty(uprop, implementation)]
    [end foreach]
    [foreach (var uop in ucls.Operations)]
    [GenerateOperation(uop, implementation)]
    [end foreach]
}
end template

template GenerateBaseClasses(Class cls)
    [$single-line]
    [string sep = " : "]
    [foreach (var gen in cls.Generalization.Select(g => g.General))]
[sep][gen.Name]
[sep = ", "]
    [end foreach]
end template

template GenerateProperty(UmlProperty uprop, bool implementation)
    [var prop = uprop.Property]
    [var overridenProps = uprop.Overrides]
    [if (!implementation)]
        [foreach (var baseProp in overridenProps.Where(p => p.IsDerived && !p.IsDerivedUnion))]
[GenerateType(baseProp, baseProp.Type)] [baseProp.Class.Name].[prop.Name.ToPascalCase()]
{
    get => this.[prop.Name.ToPascalCase()];
}

        [end foreach]
    [end if]
    [if ((implementation && prop.IsDerived && !prop.IsDerivedUnion) || (!implementation && (!prop.IsDerived || prop.IsDerivedUnion)))]
[GenerateComment(prop)]
        [if (prop.Aggregation == AggregationKind.Composite)]
["["]Containment["]"]
        [end if]
        [if (prop.IsDerivedUnion)]
["["]DerivedUnion["]"]
        [else if (prop.IsDerived)]
["["]Derived["]"]
        [end if]
        [if (IsCollection(prop) && !prop.IsUnique)]
["["]NonUnique["]"]
        [end if]
        [if (IsCollection(prop) && !prop.IsOrdered)]
["["]Unordered["]"]
        [end if]
        [if (prop.IsReadOnly)]
["["]ReadOnly["]"]
        [end if]
[GenerateOpposites(uprop)]
[GenerateRedefines(prop)]
[GenerateSubsets(prop)]
        [if (prop.DefaultValue != null)]
["["]DefaultValue([GenerateDefaultValue(prop)])["]"]
        [end if]
        [if (prop.IsDerived && !prop.IsDerivedUnion)]
public [if (overridenProps.Count > 0)]new [end if][GenerateType(prop, prop.Type)] [prop.Name.ToPascalCase()]
{ 
    get
    {
        throw new NotImplementedException();
    }
}

        [else]
[if (overridenProps.Count > 0)]new [end if][GenerateType(prop, prop.Type)] [prop.Name.ToPascalCase()] { get;[if (!prop.IsReadOnly && !IsCollection(prop))] set;[end if] }

        [end if]
    [end if]
end template

template GenerateType(MultiplicityElement me, MetaDslx.Languages.Uml.MetaModel.Type t)
[IsCollection(me) ? "IList<" : ""][GetTypeName(t)][IsCollection(me) ? ">" : IsNullable(t, me) ? "?" : ""]
end template

template GenerateRedefines(Property prop)
[foreach (var rprop in prop.RedefinedProperty)]
    [if (rprop.Class != null)]
["["]Redefines(typeof([rprop.Class.Name]), "[rprop.Name.ToPascalCase()]")["]"]
    [end if]
[end foreach]
end template

template GenerateSubsets(Property prop)
[foreach (var rprop in prop.SubsettedProperty)]
    [if (rprop.Class != null)]
["["]Subsets(typeof([rprop.Class.Name]), "[rprop.Name.ToPascalCase()]")["]"]
    [end if]
[end foreach]
end template

template GenerateOpposites(UmlProperty uprop)
[var prop = uprop.Property]
[foreach (var opposite in uprop.Opposites)]
["["]Opposite(typeof([prop.Type.Name]), "[opposite.ToPascalCase()]")["]"]
[end foreach]
end template

template GenerateOperation(UmlOperation uop, bool implementation)
    [var op = uop.Operation]
    [var overridenOps = uop.Overrides]
    [var returnType = GenerateReturnType(op)]
    [if (implementation)]
[GenerateComment(op)]
public [if (overridenOps.Count > 0)]new [end if][returnType] [op.Name.ToPascalCase()]([GenerateParams(op)])
{
    throw new NotImplementedException();
}

    [else]
        [foreach (var baseOp in overridenOps)]
[returnType] [baseOp.Class.Name].[op.Name.ToPascalCase()]([GenerateParams(op)])
{
    [if (returnType != "void")]return [end if]this.[op.Name.ToPascalCase()]([GenerateArguments(op)]);
}

        [end foreach]
    [end if]
end template

template GenerateReturnType(Operation op)
[var returnParam = op.OwnedParameter.Where(param => param.Direction == ParameterDirectionKind.Return).FirstOrDefault()]
[if (returnParam != null)][GenerateType(returnParam, returnParam.Type)][else]void[end if]
end template

template GenerateParams(Operation op)
[var incomingParams = op.OwnedParameter.Where(param => param.Direction != ParameterDirectionKind.Return)]
[foreach (var param in incomingParams) $separator ", "][GenerateType(param, param.Type)] [param.Name][end foreach]
end template

template GenerateArguments(Operation op)
[var incomingParams = op.OwnedParameter.Where(param => param.Direction != ParameterDirectionKind.Return)]
[foreach (var param in incomingParams) $separator ", "][param.Name][end foreach]
end template

template GenerateComment(Element elem)
[var comments = elem.OwnedComment.Where(comm => !string.IsNullOrWhiteSpace(comm.Body))]
[if (comments.Any())]
/// <summary>
    [foreach (var comm in comments)]
        [foreach (var line in CommentLines(comm.Body, true))]
/// [line]
        [end foreach]
    [end foreach]
/// </summary>
    [if (elem is Operation op)]
        [foreach (var param in op.OwnedParameter)]
/// <param name="[param.Name]">
            [foreach (var comm in param.OwnedComment.Where(comm => !string.IsNullOrWhiteSpace(comm.Body)))]
                [foreach (var line in CommentLines(comm.Body, true))]
/// [line]
                [end foreach]
            [end foreach]
/// </param>
        [end foreach]
    [end if]
[end if]
    [if (elem is Operation)]
[GenerateSpecification((Operation)elem)]
    [else if (elem is Property)]
        [var prop = (Property)elem]
        [if (prop.IsDerived && !prop.IsDerivedUnion)]
            [foreach (var op in prop.Class.OwnedOperation.Where(op => op.Name == prop.Name))]
[GenerateSpecification(op)]
            [end foreach]
        [end if]
    [end if]
end template

template GenerateSpecification(Namespace ns)
    [foreach (var rule in ns.OwnedRule)]
        [foreach (var comm in rule.OwnedComment.Where(comm => !string.IsNullOrWhiteSpace(comm.Body)))]
/// <para>
            [foreach (var line in CommentLines(comm.Body, true))]
/// [line]
            [end foreach]
/// </para>
        [end foreach]
// [rule.Name]:
        [if (rule.Specification is OpaqueExpression expr)]
            [foreach (var body in expr.Body)]
                [foreach (var line in CommentLines(body, false))]
//     [line]
                [end foreach]
            [end foreach]
        [end if]
    [end foreach]
end template
