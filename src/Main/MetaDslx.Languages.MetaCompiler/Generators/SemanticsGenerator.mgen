namespace MetaDslx.Languages.MetaCompiler.Generators

using MetaDslx.Languages.MetaCompiler.Model
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq

generator RoslynApiGenerator


template GenerateSemanticsFactory(Language language)
using System;
using MetaDslx.CodeAnalysis;
using MetaDslx.CodeAnalysis.Declarations;
using MetaDslx.CodeAnalysis.Binding;

#nullable enable

namespace [language.QualifiedNamespace]
{
    public class [language.Name]SemanticsFactory : SemanticsFactory
    {
        public [language.Name]SemanticsFactory(Compilation compilation, Language language) 
            : base(compilation, language)
        {
        }

        public override BinderFactoryVisitor CreateBinderFactoryVisitor(BinderFactory binderFactory)
        {
            return new [language.QualifiedNamespace].Binding.[language.Name]BinderFactoryVisitor(binderFactory);
        }
    }
}
end template


template GenerateBinderFactoryVisitor(Language language)
using System;
using System.Collections.Immutable;
using MetaDslx.CodeAnalysis;
[foreach (var use in language.Usings)]
using [if (use.Alias is not null)][use.Alias] = [end if][use.QualifiedReference];
[end foreach]

#nullable enable

namespace [language.QualifiedNamespace].Binding
{
    using [language.QualifiedNamespace].Syntax;

    public class [language.Name]BinderFactoryVisitor : MetaDslx.CodeAnalysis.Binding.BinderFactoryVisitor, I[language.Name]SyntaxVisitor
    {
        internal [language.Name]BinderFactoryVisitor(MetaDslx.CodeAnalysis.Binding.BinderFactory binderFactory)
            : base(binderFactory)
        {
        }

		[foreach (var rule in language.Grammar.ParserRules)]
			[foreach (var alt in rule.Alternatives)]

        [GenerateBinderFactoryVisit(language, rule, alt)]
			[end foreach]
		[end foreach]

		public virtual void VisitSkippedTokensTrivia([language.Name]SkippedTokensTriviaSyntax node)
		{
		}
    }
}
end template

template GenerateBinderFactoryVisit(Language language, ParserRule rule, ParserRuleAlternative alt)
public virtual void Visit[alt.CSharpName]([alt.RedName] node)
{
    [if (rule == language.Grammar.MainRule)]
    if (this.IsRoot)
    {
        [if (language.Grammar.RootType is not null)]
        var __rootAnnot = new global::MetaDslx.CodeAnalysis.Binding.RootBinder(type: typeof([language.Grammar.RootType.ToDisplayString(Microsoft.CodeAnalysis.SymbolDisplayFormat.FullyQualifiedFormat)]));
        [else]
        var __rootAnnot = new global::MetaDslx.CodeAnalysis.Binding.RootBinder(type: null);
        [end if]
        this.Begin(__rootAnnot, node);
        try
        {
            [GenerateBinderFactoryVisitBody(language, rule, alt)]
        }
        finally
        {
            this.End(__rootAnnot);
        }
    }
    else
    {
    	[GenerateBinderFactoryVisitBody(language, rule, alt)]
    }
    [else]
	[GenerateBinderFactoryVisitBody(language, rule, alt)]
    [end if]
}
end template

template GenerateBinderFactoryVisitBody(Language language, ParserRule rule, ParserRuleAlternative alt)
[var annotIndex = 0]
[var body = GenerateBinderFactoryVisitElements(language, alt, ref annotIndex)]
[body = GenerateBinderFactoryVisitAnnotations(alt.Annotations, "node", body, ref annotIndex)]
[body = GenerateBinderFactoryVisitAnnotations(rule.Annotations, "node", body, ref annotIndex)]
[body]
end template

template GenerateBinderFactoryVisitElements(Language language, ParserRuleAlternative alt, ref int annotIndex)
[foreach (var elem in alt.Elements.Where(e => e.ContainsBinders))]
[GenerateBinderFactoryVisitElement(language, alt, elem, ref annotIndex)]
[end foreach]    
end template

template GenerateBinderFactoryVisitAnnotations(IEnumerable<Annotation> annotations, string nodeName, string body, ref int annotIndex)
[foreach (var annot in annotations.Where(a => a.Kind == AnnotationKind.Binder).Reverse())]
[body = GenerateBinderFactoryVisitAnnotation(annot, nodeName, body, ref annotIndex)]
[end foreach]
[body]
end template

template GenerateBinderFactoryVisitAnnotation(Annotation annot, string nodeName, string body, ref int annotIndex)
[var annotVarName = "__annot"+(annotIndex++)]
[var annotName = annot.Name.LastOrDefault()]
var [annotVarName] = new [annot.QualifiedName]Binder([GenerateAnnotationConstructorArguments(annot)]);
this.Begin([annotVarName], [nodeName]);
try
{
    [body]
}
finally
{
    this.End([annotVarName]);
}
end template

template GenerateAnnotationConstructorArguments(Annotation annot)
[$single-line]
[foreach (var arg in annot.ConstructorArguments) separator ", "]
[arg.Name]: [arg.CSharpValue]
[end foreach]
end template

template GenerateBinderFactoryVisitElement(Language language, ParserRuleAlternative alt, ParserRuleElement elem, ref int annotIndex)
	[if (elem.IsList)]
var [elem.ParameterName]List = node.[elem.PropertyName];
for (var [elem.ParameterName]Index = 0; [elem.ParameterName]Index < [elem.ParameterName]List.Count; ++[elem.ParameterName]Index)
{
    [if (elem.IsSeparated && elem is ParserRuleListElement listElem)]
    [if (listElem.ListKind == ListKind.WithFirstItem || listElem.ListKind == ListKind.WithFirstItemSeparator)]
    if ([elem.ParameterName]Index == 0)
    {
        [var elemName = "node."+elem.PropertyName+"["+elem.ParameterName+"Index]"]
        [var elemBody = "this.Visit("+elemName+");"]
        [GenerateBinderFactoryVisitAnnotations(listElem.FirstItem.Annotations, elemName, elemBody, ref annotIndex)]
    }
    [end if]
    [if (listElem.ListKind == ListKind.WithLastItem || listElem.ListKind == ListKind.WithLastItemSeparator || listElem.ListKind == ListKind.WithFirstItemSeparator)]
    [if (listElem.ListKind == ListKind.WithFirstItemSeparator)]else [end if]if ([elem.ParameterName]Index == [elem.ParameterName]List.Count - 1)
    {
        [if (listElem.ListKind == ListKind.WithLastItem || listElem.ListKind == ListKind.WithLastItemSeparator)]
            [var elemName = "node."+elem.PropertyName+"["+elem.ParameterName+"Index]"]
            [var elemBody = "this.Visit("+elemName+");"]
        [GenerateBinderFactoryVisitAnnotations(listElem.LastItem.Annotations, elemName, elemBody, ref annotIndex)]
        [end if]
        [if (listElem.ListKind == ListKind.WithFirstItemSeparator || listElem.ListKind == ListKind.WithLastItemSeparator)]
        if ([elem.ParameterName]Index == [elem.ParameterName]List.SeparatorCount - 1)
        {
            [var elemName = "node."+elem.PropertyName+".GetSeparator("+elem.ParameterName+"Index)"]
            [var elemBody = "// this.VisitToken("+elemName+");"]
            [GenerateBinderFactoryVisitAnnotations(listElem.LastSeparator.Annotations, elemName, elemBody, ref annotIndex)]
        }
        [end if]
    }
    [end if]
    [if (listElem.ListKind == ListKind.WithFirstItem || listElem.ListKind == ListKind.WithLastItem || listElem.ListKind == ListKind.WithLastItemSeparator || listElem.ListKind == ListKind.WithFirstItemSeparator)]
    else
    {
        [var elemBody = GenerateBinderFactoryVisitListElement(listElem, out var elemName, ref annotIndex)]
        [GenerateBinderFactoryVisitAnnotations(listElem.RepeatedRule.Annotations, elemName, elemBody, ref annotIndex)]
    }
    [else]
        [var elemBody = GenerateBinderFactoryVisitListElement(listElem, out var elemName, ref annotIndex)]
    [GenerateBinderFactoryVisitAnnotations(listElem.RepeatedRule.Annotations, elemName, elemBody, ref annotIndex)]
    [end if]
        [else if (elem.IsToken)]
            [var elemName = "node."+elem.PropertyName+"["+elem.ParameterName+"Index]"]
            [var elemBody = "// this.VisitToken("+elemName+");"]
    [GenerateBinderFactoryVisitAnnotations(elem.Annotations, elemName, elemBody, ref annotIndex)]
        [else]
            [var elemName = "node."+elem.PropertyName+"["+elem.ParameterName+"Index]"]
            [var elemBody = "this.Visit("+elemName+");"]
    [GenerateBinderFactoryVisitAnnotations(elem.Annotations, elemName, elemBody, ref annotIndex)]
        [end if]
}
	[else]
		[if (elem.IsToken)]
            [var elemName = "node."+elem.PropertyName]
            [var elemBody = "// this.VisitToken("+elemName+");"]
            [if (elem is ParserRuleFixedStringAlternativesElement fixedAltsElem)]
switch (node.[elem.PropertyName].Get[language.Name]Kind())
{
                [foreach (var fixedAlt in fixedAltsElem.Alternatives)]
case [language.Name]SyntaxKind.[fixedAlt.CSharpName]:
    [GenerateBinderFactoryVisitAnnotations(fixedAlt.Annotations, elemName, elemBody, ref annotIndex)]
    break;
                [end foreach]
}
            [else]
if (node.[elem.PropertyName].Get[language.Name]Kind() != [language.Name]SyntaxKind.None)
{
    [GenerateBinderFactoryVisitAnnotations(elem.Annotations, elemName, elemBody, ref annotIndex)]
}
            [end if]
		[else]
            [var elemName = "node."+elem.PropertyName]
            [var elemBody = "this.Visit("+elemName+");"]
[GenerateBinderFactoryVisitAnnotations(elem.Annotations, elemName, elemBody, ref annotIndex)]
		[end if]
	[end if]
end template

template GenerateBinderFactoryVisitListElement(ParserRuleListElement listElem, out string itemName, ref int annotIndex)
    [var sepName = "node."+listElem.PropertyName+".GetSeparator("+listElem.ParameterName+"Index)"]
    [var sepBody = "// this.VisitToken("+sepName+");"]
    [itemName = "node."+listElem.PropertyName+"["+listElem.ParameterName+"Index]"]
    [var itemBody = "this.Visit("+itemName+");"]
    [if (listElem.IsReversed)]
[GenerateBinderFactoryVisitAnnotations(listElem.RepeatedSeparator.Annotations, sepName, sepBody, ref annotIndex)]
[GenerateBinderFactoryVisitAnnotations(listElem.RepeatedItem.Annotations, itemName, itemBody, ref annotIndex)]
    [else]
[GenerateBinderFactoryVisitAnnotations(listElem.RepeatedItem.Annotations, itemName, itemBody, ref annotIndex)]
[GenerateBinderFactoryVisitAnnotations(listElem.RepeatedSeparator.Annotations, sepName, sepBody, ref annotIndex)]
    [end if]
end template

