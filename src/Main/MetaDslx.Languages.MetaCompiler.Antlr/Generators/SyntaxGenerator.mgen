namespace MetaDslx.Languages.MetaCompiler.Antlr.Generators

using MetaDslx.Languages.MetaCompiler.Model
using System.Collections.Generic
using System.Linq
using Roslyn.Utilities

generator AntlrGenerator


template GenerateSyntaxLexer(Language language)
using MetaDslx.CodeAnalysis;
using MetaDslx.CodeAnalysis.Syntax;
using MetaDslx.CodeAnalysis.Syntax.InternalSyntax;
using MetaDslx.CodeAnalysis.Text;
using MetaDslx.Languages.MetaCompiler.Antlr;

#nullable enable

namespace [language.QualifiedNamespace].Syntax
{
    public partial class [language.Name]SyntaxLexer : AntlrSyntaxLexer
    {
        public [language.Name]SyntaxLexer(SourceText text, [language.Name]ParseOptions options) 
            : base(text, options)
        {
        }

        protected new [language.Name]Lexer AntlrLexer => ([language.Name]Lexer)base.AntlrLexer;

    }
}
end template

template GenerateSyntaxParser(Language language)
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using Antlr4.Runtime;
using Antlr4.Runtime.Tree;
using MetaDslx.CodeAnalysis;
using MetaDslx.CodeAnalysis.Syntax;
using MetaDslx.CodeAnalysis.Syntax.InternalSyntax;
using MetaDslx.CodeAnalysis.Text;
using MetaDslx.Languages.MetaCompiler.Antlr;
using [language.QualifiedNamespace].Syntax.InternalSyntax;

#nullable enable

namespace [language.QualifiedNamespace].Syntax
{
    public partial class [language.Name]SyntaxParser : AntlrSyntaxParser
    {
        private readonly AntlrToRoslynVisitor _visitor;

        public [language.Name]SyntaxParser(
            [language.Name]SyntaxLexer lexer,
			IncrementalParseData? oldParseData,
            IEnumerable<TextChangeRange> changes,
            CancellationToken cancellationToken = default)
            : base(lexer, oldParseData, changes, cancellationToken)
        {
            _visitor = new AntlrToRoslynVisitor(this);
        }

        protected new [language.Name]Parser AntlrParser => ([language.Name]Parser)base.AntlrParser;

		protected override SyntaxNode ParseRoot()
		{
            ParserState? state = null;
			GreenNode? green = this.Parse[language.Grammar.MainRule?.CSharpName](ref state);
			var red = ([language.Name]SyntaxNode)green!.CreateRed();
			return red;
		}

        private [language.Grammar.MainRule?.GreenName]? Parse[language.Grammar.MainRule?.CSharpName](ref ParserState? state)
        {
            return _visitor.Visit[language.Grammar.MainRule?.AntlrName?.ToPascalCase()](AntlrParser.[language.Grammar.MainRule?.AntlrName]());
        }

        private class AntlrToRoslynVisitor : [language.Name]ParserBaseVisitor<GreenNode?>
        {
			// list pools - allocators for lists that are used to build sequences of nodes. The lists
			// can be reused (hence pooled) since the syntax factory methods don't keep references to
			// them
			private readonly SyntaxListPool _pool = new SyntaxListPool(); // Don't need to reset this.

            private readonly [language.Name]SyntaxParser _parser;
            private readonly AntlrTokenStream _tokenStream;
			private readonly [language.Name]InternalSyntaxFactory _factory;

            public AntlrToRoslynVisitor([language.Name]SyntaxParser parser)
            {
                _parser = parser;
                _tokenStream = (AntlrTokenStream)_parser.AntlrParser.InputStream;
				_factory = ([language.Name]InternalSyntaxFactory)_parser.Language.InternalSyntaxFactory;
            }

            private InternalSyntaxToken? VisitTerminal(IToken? token, [language.Name]SyntaxKind kind)
            {
				if (token == null)
				{
					if (kind != [language.Name]SyntaxKind.None) return _factory.MissingToken(kind);
					else return null;
				}
                var green = _tokenStream.ConsumeGreenToken(token, _parser);
				Debug.Assert(kind == [language.Name]SyntaxKind.None || green.RawKind == (int)kind);
				return green;
            }

            public InternalSyntaxToken? VisitTerminal(IToken? token)
            {
				return VisitTerminal(token, [language.Name]SyntaxKind.None);
            }

            private InternalSyntaxToken? VisitTerminal(ITerminalNode? node, [language.Name]SyntaxKind kind)
            {
                if (node?.Symbol == null)
				{
					if (kind != [language.Name]SyntaxKind.None) return _factory.MissingToken(kind);
					else return null;
				}
                var green = _tokenStream.ConsumeGreenToken(node.Symbol, _parser);
				Debug.Assert(kind == [language.Name]SyntaxKind.None || green.RawKind == (int)kind);
				return green;
			}

            public override InternalSyntaxToken? VisitTerminal(ITerminalNode? node)
            {
                return VisitTerminal(node, [language.Name]SyntaxKind.None);
            }

            [foreach (var rule in language.Grammar.ParserRules)]
                [foreach (var alt in rule.Alternatives)]
            public override [alt.GreenName]? Visit[alt.AntlrName.ToPascalCase()]([language.Name]Parser.[alt.AntlrName.ToPascalCase()]Context? context)
            {
               	if (context == null) return [alt.GreenName].__Missing;
                [foreach (var elem in alt.Elements)]
                    [if (elem.IsList)]
                        [if (elem.IsSeparated && elem is ParserRuleListElement listElem)]
                var [elem.ParameterName]Builder = _pool.AllocateSeparated<[elem.GreenItemType]>(reversed: [listElem.IsReversed ? "true" : "false"]);
                            [if (listElem.ListKind == ListKind.WithFirstItem || listElem.ListKind == ListKind.WithFirstItemSeparator)]
                var [listElem.FirstItem.ParameterName]Context = context.[listElem.FirstItem.AntlrName];
                if ([listElem.FirstItem.ParameterName]Context is not null) [elem.ParameterName]Builder.Add(([listElem.FirstItem.GreenItemType]?)this.Visit([listElem.FirstItem.ParameterName]Context) ?? [listElem.FirstItem.GreenItemType].__Missing);
                                [if (!listElem.FirstItem.IsOptional)]
                else [elem.ParameterName]Builder.Add([listElem.FirstItem.GreenItemType].__Missing);
                                [end if]
                            [end if]
                var [elem.ParameterName]Context = context._[listElem.RepeatedRule.AntlrName];
                for (int i = 0; i < [elem.ParameterName]Context.Count; ++i)
                {
                    var itemContext = [elem.ParameterName]Context["[i]"];
                    if (itemContext is not null)
                    {
                        var item = itemContext.[listElem.RepeatedItem.AntlrName];
                        var separator = itemContext.[listElem.RepeatedSeparator.AntlrName];
                            [if (listElem.ListKind == ListKind.SeparatorItem || listElem.ListKind == ListKind.WithFirstItem || listElem.ListKind == ListKind.WithFirstItemSeparator)]
                        [elem.ParameterName]Builder.AddSeparator(this.VisitTerminal(separator, [language.Name]SyntaxKind.[listElem.RepeatedSeparator.CSharpName]));
                        if (item is not null) [elem.ParameterName]Builder.Add(([elem.GreenItemType]?)this.Visit(item) ?? [elem.GreenItemType].__Missing);
                        else [elem.ParameterName]Builder.Add([elem.GreenItemType].__Missing);
                            [else]
                        if (item is not null) [elem.ParameterName]Builder.Add(([elem.GreenItemType]?)this.Visit(item) ?? [elem.GreenItemType].__Missing);
                        else [elem.ParameterName]Builder.Add([elem.GreenItemType].__Missing);
                        [elem.ParameterName]Builder.AddSeparator(this.VisitTerminal(separator, [language.Name]SyntaxKind.[listElem.RepeatedSeparator.CSharpName]));
                            [end if]
                    }
                }
                            [if (listElem.ListKind == ListKind.WithLastItem || listElem.ListKind == ListKind.WithLastItemSeparator)]
                var [listElem.LastItem.ParameterName]Context = context.[listElem.LastItem.AntlrName];
                if ([listElem.LastItem.ParameterName]Context is not null) [elem.ParameterName]Builder.Add(([listElem.LastItem.GreenItemType]?)this.Visit([listElem.LastItem.ParameterName]Context) ?? [listElem.LastItem.GreenItemType].__Missing);
                                [if (!listElem.LastItem.IsOptional)]
                else  [elem.ParameterName]Builder.Add([listElem.LastItem.GreenItemType].__Missing);
                                [end if]
                            [end if]
                            [if (listElem.ListKind == ListKind.WithFirstItemSeparator || listElem.ListKind == ListKind.WithLastItemSeparator)]
                var [listElem.LastSeparator.ParameterName]Context = context.[listElem.LastSeparator.AntlrName];
                                [if (listElem.LastSeparator.IsOptional)]
                if ([listElem.LastSeparator.ParameterName]Context is not null) [elem.ParameterName]Builder.AddSeparator(this.VisitTerminal([listElem.LastSeparator.ParameterName]Context));
                                [else]
                [elem.ParameterName]Builder.AddSeparator(this.VisitTerminal([listElem.LastSeparator.ParameterName]Context, [language.Name]SyntaxKind.[listElem.LastSeparator.CSharpName]));
                                [end if]
                            [end if]
                var [elem.ParameterName] = [elem.ParameterName]Builder.ToList();
                _pool.Free([elem.ParameterName]Builder);
                        [else]
                var [elem.ParameterName]Context = context._[elem.AntlrName];
                var [elem.ParameterName]Builder = _pool.Allocate<[elem.GreenItemType]>();
                for (int i = 0; i < [elem.ParameterName]Context.Count; ++i)
                {
                            [if(elem.IsToken)]
                    [elem.ParameterName]Builder.Add(this.VisitTerminal([elem.ParameterName]Context["[i]"]));
                            [else]
                    if ([elem.ParameterName]Context["[i]"] is not null) [elem.ParameterName]Builder.Add(([elem.GreenItemType]?)this.Visit([elem.ParameterName]Context["[i]"]) ?? [elem.GreenItemType].__Missing);
                    else [elem.ParameterName]Builder.Add([elem.GreenItemType].__Missing);
                            [end if]
                }
                var [elem.ParameterName] = [elem.ParameterName]Builder.ToList();
                _pool.Free([elem.ParameterName]Builder);
                        [end if]
                    [else]
                        [if(elem is ParserRuleFixedStringAlternativesElement fixedAlts)]
                InternalSyntaxToken? [elem.ParameterName] = null;
                            [foreach (var fixedAlt in fixedAlts.Alternatives)]
                if (context.[fixedAlt.AntlrName] is not null) [elem.ParameterName] = this.VisitTerminal(context.[fixedAlt.AntlrName]);
                            [end foreach]
                        [else if(elem is ParserRuleFixedStringElement fixedElem)]
                var [elem.ParameterName] = this.VisitTerminal(context.[elem.AntlrName][if (!elem.IsOptional)], [language.Name]SyntaxKind.[fixedElem.LexerRule.CSharpName][end if]);
                        [else if(elem.IsToken && elem is ParserRuleReferenceElement ruleRefElem)]
                var [elem.ParameterName] = this.VisitTerminal(context.[elem.AntlrName][if (!elem.IsOptional)], [language.Name]SyntaxKind.[ruleRefElem.Rule.CSharpName][end if]);
                        [else if(elem.IsToken)]
                var [elem.ParameterName] = this.VisitTerminal(context.[elem.AntlrName]);
                        [else]
                [elem.GreenItemType]? [elem.ParameterName] = null;
                if (context.[elem.AntlrName] is not null) [elem.ParameterName] = ([elem.GreenItemType]?)this.Visit(context.[elem.AntlrName])[if (!elem.IsOptional)] ?? [elem.GreenItemType].__Missing[end if];
                            [if (!elem.IsOptional)]
                else [elem.ParameterName] = [elem.GreenItemType].__Missing;
                            [end if]
                        [end if]
                    [end if]
                [end foreach]
            	return _factory.[alt.CSharpName]([alt.GreenUpdateArguments]);
            }
                [end foreach]
            [end foreach]
        }
    }
}
end template

template GenerateInternalSyntaxFactory(Language language)
using MetaDslx.CodeAnalysis;
using MetaDslx.CodeAnalysis.Syntax;
using MetaDslx.CodeAnalysis.Syntax.InternalSyntax;
using MetaDslx.Languages.MetaCompiler.Antlr;
using Antlr4.Runtime;

#nullable enable

namespace [language.QualifiedNamespace].Syntax.InternalSyntax
{
    public partial class [language.Name]InternalSyntaxFactory : IAntlrSyntaxFactory
    {
	    AntlrLexer IAntlrSyntaxFactory.CreateAntlrLexer(ICharStream input)
	    {
	        return new [language.Name]Lexer(input);
	    }
	
	    AntlrParser IAntlrSyntaxFactory.CreateAntlrParser(ITokenStream input)
	    {
	        return new [language.Name]Parser(input);
	    }
    }
}
end template

