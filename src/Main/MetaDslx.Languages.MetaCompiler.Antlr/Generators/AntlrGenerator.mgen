namespace MetaDslx.Languages.MetaCompiler.Antlr.Generators

using MetaDslx.Languages.MetaCompiler.Model
using System.Collections.Generic
using System.Linq

generator AntlrGenerator

template GenerateLexer(Language language)
lexer grammar [language.Name]Lexer;

[foreach (var rule in language.Grammar.FixedLexerRules)]
[GenerateLexerRule(rule)]
[end foreach]
[foreach (var rule in language.Grammar.NonFixedLexerRules)]
[GenerateLexerRule(rule)]
[end foreach]
end template

template GenerateLexerRule(LexerRule rule)
[rule.IsFragment ? "fragment " : ""][rule.AntlrName]: [GenerateLexerRuleAlts(rule.Alternatives)][rule.IsHidden ? " -> channel(HIDDEN)" : ""];
end template

template GenerateLexerRuleAlts(List<LexerRuleAlternative> alternatives)
[-]
[foreach (var alt in alternatives) separator " | "]
[GenerateLexerRuleElements(alt)]
[end foreach]
end template

template GenerateLexerRuleElements(LexerRuleAlternative alt)
[-]
[foreach (var elem in alt.Elements) separator " "]
[elem.IsNegated ? "~" : ""][GenerateLexerRuleElement(elem)][GenerateMultiplicity(elem.Multiplicity)]
[end foreach]
end template

template GenerateLexerRuleElement(LexerRuleElement elem)
[-]
[if (elem is LexerRuleReferenceElement ruleRefElem)]
[ruleRefElem.Rule.AntlrName]
[else if (elem is LexerRuleFixedStringElement fixedElem)]
[fixedElem.ValueText]
[else if (elem is LexerRuleWildcardElement wildcardElem)]
.
[else if (elem is LexerRuleBlockElement blockElem)]
([GenerateLexerRuleAlts(blockElem.Alternatives)])
[else if (elem is LexerRuleRangeElement rangeElem)]
[rangeElem.StartText]..[rangeElem.EndText]
[else]
!!! ERROR: unknown lexer rule element type [elem.GetType()]
[end if]
end template

template GenerateMultiplicity(Multiplicity multiplicity)
[-]
[if (multiplicity == Multiplicity.ZeroOrOne)]?
[else if (multiplicity == Multiplicity.ZeroOrMore)]*
[else if (multiplicity == Multiplicity.OneOrMore)]+
[else if (multiplicity == Multiplicity.NonGreedyZeroOrOne)]??
[else if (multiplicity == Multiplicity.NonGreedyZeroOrMore)]*?
[else if (multiplicity == Multiplicity.NonGreedyOneOrMore)]+?
[end if]
end template

template GenerateAssignment(Multiplicity multiplicity)
[-]
[if (multiplicity.IsList())]+=[else]=[end if]
end template


template GenerateParser(Language language)
parser grammar [language.Name]Parser;

options
{
    tokenVocab = [language.Name]Lexer; 
} 

[foreach (var rule in language.Grammar.ParserRules)]
[GenerateParserRule(rule)]
[end foreach]
end template

template GenerateParserRule(ParserRule rule)
[rule.AntlrName]
    [GenerateParserRuleAlts(rule.Alternatives)]
    ;
end template

template GenerateParserRuleAlts(List<ParserRuleAlternative> alternatives)
[var sep = ":"]
[foreach (var alt in alternatives)]
[sep] [GenerateParserRuleElements(alt)][if (alternatives.Count > 1)] #[alt.AntlrName][end if]
[sep = "|"]
[end foreach]
end template

template GenerateParserRuleElements(ParserRuleAlternative alt)
[-]
[foreach (var elem in alt.Elements) separator " "]
[GenerateParserRuleElement(elem)]
[end foreach]
end template

template GenerateParserRuleElement(ParserRuleElement elem)
[-]
[if (elem is ParserRuleReferenceElement ruleRefElem)]
 [elem.AntlrName][GenerateAssignment(elem.Multiplicity)][elem.IsNegated ? "~" : ""][ruleRefElem.Rule.AntlrName][GenerateMultiplicity(elem.Multiplicity)]
[else if (elem is ParserRuleEofElement eofElem)]
 [elem.AntlrName][GenerateAssignment(elem.Multiplicity)]EOF
[else if (elem is ParserRuleFixedStringElement fixedElem)]
 [elem.AntlrName][GenerateAssignment(elem.Multiplicity)][elem.IsNegated ? "~" : ""][fixedElem.LexerRule.AntlrName][GenerateMultiplicity(elem.Multiplicity)]
[else if (elem is ParserRuleFixedStringAlternativesElement fixedAltsElem)]
 [elem.IsNegated ? "~" : ""]([foreach (var fixedAlt in fixedAltsElem.Alternatives) separator " | "][GenerateParserRuleElement(fixedAlt)][end foreach])[GenerateMultiplicity(elem.Multiplicity)]
[else if (elem is ParserRuleWildcardElement wildcardElem)]
 [elem.AntlrName][GenerateAssignment(elem.Multiplicity)][elem.IsNegated ? "~" : ""].[GenerateMultiplicity(elem.Multiplicity)]
[else if (elem is ParserRuleBlockElement blockElem)]
 [elem.AntlrName][GenerateAssignment(elem.Multiplicity)][elem.IsNegated ? "~" : ""]([GenerateParserRuleAlts(blockElem.Alternatives)])[GenerateMultiplicity(elem.Multiplicity)]
[else if (elem is ParserRuleListElement listElem)]
    [if (listElem.ListKind == ListKind.WithFirstItem || listElem.ListKind == ListKind.WithFirstItemSeparator)]
 [GenerateParserRuleElement(listElem.FirstItem)]
    [end if]
 [GenerateParserRuleElement(listElem.RepeatedRule)]
    [if (listElem.ListKind == ListKind.WithLastItem || listElem.ListKind == ListKind.WithLastItemSeparator)]
 [GenerateParserRuleElement(listElem.LastItem)]
    [end if]
    [if (listElem.ListKind == ListKind.WithFirstItemSeparator || listElem.ListKind == ListKind.WithLastItemSeparator)]
 [GenerateParserRuleElement(listElem.LastSeparator)]
    [end if]
[else]
!!! ERROR: unknown lexer rule element type [elem.GetType()]
[end if]
end template
