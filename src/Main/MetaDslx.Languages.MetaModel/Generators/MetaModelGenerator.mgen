namespace MetaDslx.Languages.MetaModel.Generators;

using System;
using System.Linq;
using Roslyn.Utilities;
using MetaDslx.Languages.MetaModel.Model;

generator MetaModelGenerator;

template Generate()
namespace [Namespace]
{
	using __MetaMetaModel = global::MetaDslx.Languages.MetaModel.Model.Meta;
	using __MetaModelFactory = global::MetaDslx.Languages.MetaModel.Model.MetaModelFactory;
	using __Model = global::MetaDslx.Modeling.Model;
	using __MetaModel = global::MetaDslx.Modeling.MetaModel;
	using __IModelObject = global::MetaDslx.Modeling.IModelObject;
	using __ModelFactory = global::MetaDslx.Modeling.ModelFactory;
	using __MultiModelFactory = global::MetaDslx.Modeling.MultiModelFactory;
	using __ModelVersion = global::MetaDslx.Modeling.ModelVersion;
	using __ModelObjectInfo = global::MetaDslx.Modeling.ModelObjectInfo;
	using __ModelProperty = global::MetaDslx.Modeling.ModelProperty;
    using __ModelPropertyFlags = global::MetaDslx.Modeling.ModelPropertyFlags;
	using __ModelOperation = global::MetaDslx.Modeling.ModelOperation;
	using __ModelOperationInfo = global::MetaDslx.Modeling.ModelOperationInfo;
	using __ImmutableArray = global::System.Collections.Immutable.ImmutableArray;
	using __ImmutableDictionary = global::System.Collections.Immutable.ImmutableDictionary;
	using __MetaType = global::MetaDslx.CodeAnalysis.MetaType;
	using __MetaSymbol = global::MetaDslx.CodeAnalysis.MetaSymbol;
	using __Type = global::System.Type;

	[GenerateMetaModel(MetaModel)]
	
	[GenerateFactory(MetaModel)]

	[foreach (var enm in Enums)]
	[GenerateEnum(MetaModel, enm)]

	[end foreach]

	[foreach (var cls in Classes)]
	[GenerateInterface(MetaModel, cls)]

	[end foreach]

	[GenerateCustomInterface(MetaModel)]
	
	[GenerateCustomImplementation(MetaModel)]
}

namespace [Namespace].__Impl
{
	using __Model = global::MetaDslx.Modeling.Model;
	using __MetaModel = global::MetaDslx.Modeling.MetaModel;
	using __IModelObject = global::MetaDslx.Modeling.IModelObject;
	using __MetaModelObject = global::MetaDslx.Modeling.MetaModelObject;
	using __ModelObjectInfo = global::MetaDslx.Modeling.ModelObjectInfo;
	using __ModelProperty = global::MetaDslx.Modeling.ModelProperty;
	using __ModelPropertyFlags = global::MetaDslx.Modeling.ModelPropertyFlags;
	using __ModelPropertyInfo = global::MetaDslx.Modeling.ModelPropertyInfo;
	using __ModelPropertySlot = global::MetaDslx.Modeling.ModelPropertySlot;
	using __ModelOperation = global::MetaDslx.Modeling.ModelOperation;
	using __ModelOperationInfo = global::MetaDslx.Modeling.ModelOperationInfo;
	using __ImmutableArray = global::System.Collections.Immutable.ImmutableArray;
	using __ImmutableDictionary = global::System.Collections.Immutable.ImmutableDictionary;
	using __MetaType = global::MetaDslx.CodeAnalysis.MetaType;
	using __MetaSymbol = global::MetaDslx.CodeAnalysis.MetaSymbol;
	using __Type = global::System.Type;

	[foreach (var cls in Classes)]
	[GenerateClass(MetaModel, cls)]

	[end foreach]
}
end template

template GenerateMetaModel(MetaModel mm)
internal interface I[mm.Name]
{
	[foreach (var c in mm.Parent.Declarations.OfType<MetaConstant>())]
	[ToCSharp(c.Type)] [c.Name] { get; }
	[end foreach]
}

public sealed class [mm.Name] : __MetaModel, I[mm.Name]
{
	// If there is an error at the following line, create a new class called 'Custom[mm.Name]Implementation'
	// inheriting from the class 'Custom[mm.Name]ImplementationBase' and provide the custom implementation
	// for the derived properties and operations defined in the metamodel
	internal static readonly Custom[mm.Name]ImplementationBase __CustomImpl = new Custom[mm.Name]Implementation();

	private static readonly [mm.Name] _instance;
	public static [mm.Name] Instance => _instance;

	[foreach (var cls in mm.Parent.Declarations.OfType<MetaClass>())]
	[foreach (var prop in cls.Properties)]
	private static readonly __ModelProperty _[cls.Name]_[prop.Name];
	[end foreach]
	[foreach (var op in cls.Operations)]
	private static readonly __ModelOperation _[cls.Name]_[op.Name];
	[end foreach]
	[end foreach]

	static [mm.Name]()
	{
		[foreach (var cls in Classes)]
			[var metaCls = Graph.GetMetaClass(MetaDslx.CodeAnalysis.MetaType.FromModelObject((MetaDslx.Modeling.IModelObject)cls))]
			[foreach (var prop in metaCls.DeclaredProperties)]
		_[cls.Name]_[prop.Name] = new __ModelProperty(typeof([cls.Name]), "[prop.Name]", typeof([ToCSharp(prop.Type)]), null, [ToCSharp(prop.Flags)], [if(prop.SymbolProperty is null)]null[else]"[prop.SymbolProperty]"[end if]);
			[end foreach]
			[foreach (var op in metaCls.DeclaredOperations)]
		_[cls.Name]_[op.Name] = new __ModelOperation(typeof([cls.Name]), "[op.Name]", "[op.Name]([op.UnderlyingOperation.Parameters.Count])");
			[end foreach]
		[end foreach]
		_instance = new [mm.Name]();
	}

	private readonly __Model _model;
	private readonly global::System.Collections.Immutable.ImmutableArray<__Type> _modelObjectTypes;
	private readonly global::System.Collections.Immutable.ImmutableArray<__ModelObjectInfo> _modelObjectInfos;
	private readonly global::System.Collections.Immutable.ImmutableDictionary<__Type, __ModelObjectInfo> _modelObjectInfosByType;
	private readonly global::System.Collections.Immutable.ImmutableDictionary<string, __ModelObjectInfo> _modelObjectInfosByName;

	[foreach (var c in mm.Parent.Declarations.OfType<MetaConstant>())]
	private readonly [ToCSharp(c.Type)] _[c.Name.ToCamelCase()];
	[end foreach]

	private [mm.Name]()
	{
		_modelObjectTypes = __ImmutableArray.Create<__Type>([foreach (var cls in mm.Parent.Declarations.OfType<MetaClass>()) separator ", "]typeof([cls.Name])[end foreach]);
		_modelObjectInfos = __ImmutableArray.Create<__ModelObjectInfo>([foreach (var cls in mm.Parent.Declarations.OfType<MetaClass>()) separator ", "][cls.Name]Info[end foreach]);
		var modelObjectInfosByType = __ImmutableDictionary.CreateBuilder<__Type, __ModelObjectInfo>();
		[foreach (var cls in Classes)]
		modelObjectInfosByType.Add(typeof([cls.Name]), [cls.Name]Info);
		[end foreach]
		_modelObjectInfosByType = modelObjectInfosByType.ToImmutable();
		var modelObjectInfosByName = __ImmutableDictionary.CreateBuilder<string, __ModelObjectInfo>();
		[foreach (var cls in Classes)]
		modelObjectInfosByName.Add("[cls.Name]", [cls.Name]Info);
		[end foreach]
		_modelObjectInfosByName = modelObjectInfosByName.ToImmutable();
		_model = new __Model();
		var f = new __MetaModelFactory(_model);
		[foreach (var c in mm.Parent.Declarations.OfType<MetaConstant>())]
		_[c.Name.ToCamelCase()] = f.[c.Type.Name]();
		[end foreach]
		[foreach (var obj in ModelObjects)]
		var [GetName(obj)] = f.[obj.MetaType.Name]();
		[end foreach]
		__CustomImpl.[mm.Name](this);
		[foreach (var obj in ModelObjects)]
			[foreach (var child in obj.Children)]
		((__IModelObject)[GetName(obj)]).Children.Add((__IModelObject)[GetName(child)]);
			[end foreach]
			[foreach (var prop in obj.PublicProperties.Where(p => !obj.IsDefault(p)))]
				[if (prop.IsCollection)]
					[foreach (var value in obj.GetValues(prop))]
		[GetName(obj)].[prop.Name].Add([ToCSharpValue(prop, value)]);
					[end foreach]
				[else if (!prop.IsReadOnly)]
		[GetName(obj)].[prop.Name] = [ToCSharpValue(prop, obj.Get(prop))];
				[end if]
			[end foreach]
		[end foreach]
		_model.IsSealed = true;
	}

    public override string Name => nameof([mm.Name]);
    public override string Namespace => "[Namespace]";
    public override __ModelVersion Version => default;
    public override string Uri => "[mm.FullName]";
    public override string Prefix => "[string.Concat(mm.Name.Where(c => char.IsUpper(c)).Select(c => char.ToLower(c)))]";
	public override __Model Model => _model;

	public override global::System.Collections.Immutable.ImmutableArray<__Type> ModelObjectTypes => _modelObjectTypes;
	public override global::System.Collections.Immutable.ImmutableArray<__ModelObjectInfo> ModelObjectInfos => _modelObjectInfos;

    public override bool Contains(__Type modelObjectType) => _modelObjectInfosByType.ContainsKey(modelObjectType);
    public override bool Contains(string modelObjectTypeName) => _modelObjectInfosByName.ContainsKey(modelObjectTypeName);

    public override bool TryGetInfo(__Type modelObjectType, out __ModelObjectInfo? info) => _modelObjectInfosByType.TryGetValue(modelObjectType, out info);
    public override bool TryGetInfo(string modelObjectTypeName, out __ModelObjectInfo? info) => _modelObjectInfosByName.TryGetValue(modelObjectTypeName, out info);

	[foreach (var c in mm.Parent.Declarations.OfType<MetaConstant>())]
	[ToCSharp(c.Type)] I[mm.Name].[c.Name] => _[c.Name.ToCamelCase()];
	[end foreach]

	[foreach (var c in mm.Parent.Declarations.OfType<MetaConstant>())]
	public static [ToCSharp(c.Type)] [c.Name] => ((I[mm.Name])Instance).[c.Name];
	[end foreach]

	[foreach (var cls in Classes)]
	public static __ModelObjectInfo [cls.Name]Info => global::[Namespace].__Impl.[cls.Name]_Impl.__Info.Instance;
	[foreach (var prop in cls.Properties)]
	public static __ModelProperty [cls.Name]_[prop.Name] => _[cls.Name]_[prop.Name];
	[end foreach]
	[foreach (var op in cls.Operations)]
	public static __ModelOperation [cls.Name]_[op.Name] => _[cls.Name]_[op.Name];
	[end foreach]
	[end foreach]
}
end template

template GenerateFactory(MetaModel mm)
public class [mm.Name]ModelFactory : __ModelFactory
{
	public [mm.Name]ModelFactory(__Model model)
		: base(model, [mm.Name].Instance)
	{
	}

	[foreach (var cls in Classes.Where(c => !c.IsAbstract))]
	public [ToCSharp(cls)] [cls.Name](string? id = null)
	{
		return ([ToCSharp(cls)])[mm.Name].[cls.Name]Info.Create(Model, id)!;
	}

	[end foreach]
}

public class [mm.Name]ModelMultiFactory : __MultiModelFactory
{
	public [mm.Name]ModelMultiFactory()
		: base(new __MetaModel["[]"] { [mm.Name].Instance })
	{
	}

	[foreach (var cls in Classes.Where(c => !c.IsAbstract))]
	public [ToCSharp(cls)] [cls.Name](__Model model, string? id = null)
	{
		return ([ToCSharp(cls)])[mm.Name].[cls.Name]Info.Create(model, id)!;
	}

	[end foreach]
}

end template

template GenerateEnum(MetaModel mm, MetaEnumType enm)
public enum [enm.Name]
{
	[foreach (var lit in enm.Literals)]
	[lit.Name],
	[end foreach]
}
end template

template GenerateInterface(MetaModel mm, MetaClass cls)
[var metaCls = Graph.GetMetaClass(MetaDslx.CodeAnalysis.MetaType.FromModelObject((MetaDslx.Modeling.IModelObject)cls))]
public interface [cls.Name][if (cls.BaseTypes.Any())] : [foreach (var bt in cls.BaseTypes) separator ", "]global::[bt.FullName][end foreach][else] : __IModelObject[end if]
{
	[foreach (var prop in metaCls.DeclaredProperties)]
	[var info = metaCls.ModelPropertyInfos[prop]]
	[if (info.HidingProperties.Length > 0)]new [end if][ToCSharp(prop.UnderlyingProperty.Type)] [prop.Name] { get; [if (HasSetter(prop))]set; [end if]}
	[end foreach]

	[foreach (var op in cls.Operations)]
	[ToCSharp(op.ReturnType)] [op.Name]([foreach (var param in op.Parameters) separator ", "][ToCSharp(param.Type)] [param.Name][end foreach]);
	[end foreach]
}
end template

template GenerateClass(MetaModel mm, MetaClass cls)
[var metaCls = Graph.GetMetaClass(MetaDslx.CodeAnalysis.MetaType.FromModelObject((MetaDslx.Modeling.IModelObject)cls))]
internal class [cls.Name]_Impl : __MetaModelObject, [cls.Name]
{
	private [cls.Name]_Impl(string? id)
		: base(id)
	{
		[foreach (var slot in metaCls.Slots)]
			[if (IsCollection(slot))]
		((__IModelObject)this).Init([ToCSharp(slot.SlotProperty)], new global::MetaDslx.Modeling.ModelObjectList<[ToCSharp(slot.SlotProperty.Type)]>(this, __Info.Instance.GetSlot([ToCSharp(slot.SlotProperty)])!));
			[else if (slot.DefaultValue is not null)]
		((__IModelObject)this).Init([ToCSharp(slot.SlotProperty)], ([ToCSharp(slot.SlotProperty.Type)])[ToCSharpValue(slot.SlotProperty, slot.DefaultValue)]);
			[end if]
		[end foreach]
		[foreach (var baseType in metaCls.AllBaseTypes.Reverse())]
		[mm.Name].__CustomImpl.[baseType.Name](this);
		[end foreach]
		[mm.Name].__CustomImpl.[cls.Name](this);
	}

	public override __ModelObjectInfo MInfo => __Info.Instance;

	[foreach (var prop in metaCls.AllDeclaredProperties)]
		[var info = metaCls.ModelPropertyInfos[prop]]
		[if (metaCls.PublicProperties.Contains(prop))]
	public [ToCSharp(prop.UnderlyingProperty.Type)] [prop.Name]
		[else]
	["["]global::System.Diagnostics.DebuggerBrowsable(global::System.Diagnostics.DebuggerBrowsableState.Never)["]"]
	[ToCSharp(prop.UnderlyingProperty.Type)] [ToCSharp(prop.DeclaringType.UnderlyingType)].[prop.Name]
		[end if]
	{
		[if (prop.UnderlyingProperty.IsDerived)]
			[var actualProp = info.HidingProperties.FirstOrDefault() ?? prop]
		get => [mm.Name].__CustomImpl.[actualProp.DeclaringType.Name]_[actualProp.Name](this);
		[else if (prop.IsCollection)]
		get => MGetCollection<[ToCSharp(prop.Type)]>([ToCSharp(prop)]);
		[else]
		get => MGet<[ToCSharp(prop.UnderlyingProperty.Type)]>([ToCSharp(prop)]);
			[if (HasSetter(prop))]
		set => MAdd<[ToCSharp(prop.UnderlyingProperty.Type)]>([ToCSharp(prop)], value);
			[end if]
		[end if]
	}

	[end foreach]

	[foreach (var op in metaCls.AllDeclaredOperations)]
		[var info = metaCls.ModelOperationInfos[op]]
		[var actualOp = info.OverridingOperations.FirstOrDefault() ?? op]
	[ToCSharp(op.UnderlyingOperation.ReturnType)] [ToCSharp(op.DeclaringType.UnderlyingType)].[op.Name]([foreach (var param in op.UnderlyingOperation.Parameters) separator ", "][ToCSharp(param.Type)] [param.Name][end foreach]) => [mm.Name].__CustomImpl.[actualOp.DeclaringType.Name]_[actualOp.Name](this[foreach (var param in actualOp.UnderlyingOperation.Parameters)], [param.Name][end foreach]);
	[end foreach]

	internal class __Info : __ModelObjectInfo
	{
		public static readonly __Info Instance = new __Info();

		private readonly global::System.Collections.Immutable.ImmutableArray<__ModelObjectInfo> _baseTypes;
		private readonly global::System.Collections.Immutable.ImmutableArray<__ModelObjectInfo> _allBaseTypes;
		private readonly global::System.Collections.Immutable.ImmutableArray<__ModelProperty> _declaredProperties;
		private readonly global::System.Collections.Immutable.ImmutableArray<__ModelProperty> _allDeclaredProperties;
		private readonly global::System.Collections.Immutable.ImmutableArray<__ModelProperty> _publicProperties;
        private readonly global::System.Collections.Immutable.ImmutableDictionary<string, __ModelProperty> _publicPropertiesByName;
        private readonly global::System.Collections.Immutable.ImmutableDictionary<__ModelProperty, __ModelPropertyInfo> _modelPropertyInfos;
		private readonly global::System.Collections.Immutable.ImmutableArray<__ModelOperation> _declaredOperations;
		private readonly global::System.Collections.Immutable.ImmutableArray<__ModelOperation> _allDeclaredOperations;
		private readonly global::System.Collections.Immutable.ImmutableArray<__ModelOperation> _publicOperations;
        private readonly global::System.Collections.Immutable.ImmutableDictionary<__ModelOperation, __ModelOperationInfo> _modelOperationInfos;

		private __Info() 
		{
			_baseTypes = __ImmutableArray.Create<__ModelObjectInfo>([foreach (var bt in metaCls.BaseTypes) separator ", "][ToCSharp(bt)][end foreach]);
			_allBaseTypes = __ImmutableArray.Create<__ModelObjectInfo>([foreach (var bt in metaCls.AllBaseTypes) separator ", "][ToCSharp(bt)][end foreach]);
			_declaredProperties = __ImmutableArray.Create<__ModelProperty>([foreach (var prop in metaCls.DeclaredProperties) separator ", "][ToCSharp(prop)][end foreach]);
			_allDeclaredProperties = __ImmutableArray.Create<__ModelProperty>([foreach (var prop in metaCls.AllDeclaredProperties) separator ", "][ToCSharp(prop)][end foreach]);
			_publicProperties = __ImmutableArray.Create<__ModelProperty>([foreach (var prop in metaCls.PublicProperties) separator ", "][ToCSharp(prop)][end foreach]);
			var publicPropertiesByName = __ImmutableDictionary.CreateBuilder<string, __ModelProperty>();
			[foreach (var prop in metaCls.PublicProperties)]
			publicPropertiesByName.Add("[prop.Name]", [ToCSharp(prop)]);
			[end foreach]
			_publicPropertiesByName = publicPropertiesByName.ToImmutable();
			var modelPropertyInfos = __ImmutableDictionary.CreateBuilder<__ModelProperty, __ModelPropertyInfo>();
			[foreach (var prop in metaCls.AllDeclaredProperties)]
			[var info = metaCls.ModelPropertyInfos[prop]]
			[var slot = info.Slot]
			modelPropertyInfos.Add([ToCSharp(prop)], new __ModelPropertyInfo(new __ModelPropertySlot([ToCSharp(slot.SlotProperty)], [ToCSharp(slot.SlotProperties)], null, [ToCSharp(slot.Flags)]), [ToCSharp(info.OppositeProperties)], [ToCSharp(info.SubsettedProperties)], [ToCSharp(info.SubsettingProperties)], [ToCSharp(info.RedefinedProperties)], [ToCSharp(info.RedefiningProperties)], [ToCSharp(info.HiddenProperties)], [ToCSharp(info.HidingProperties)]));
			[end foreach]
			_modelPropertyInfos = modelPropertyInfos.ToImmutable();

			_declaredOperations = __ImmutableArray.Create<__ModelOperation>([foreach (var op in metaCls.DeclaredOperations) separator ", "][ToCSharp(op)][end foreach]);
			_allDeclaredOperations = __ImmutableArray.Create<__ModelOperation>([foreach (var op in metaCls.AllDeclaredOperations) separator ", "][ToCSharp(op)][end foreach]);
			_publicOperations = __ImmutableArray.Create<__ModelOperation>([foreach (var op in metaCls.PublicOperations) separator ", "][ToCSharp(op)][end foreach]);
			var modelOperationInfos = __ImmutableDictionary.CreateBuilder<__ModelOperation, __ModelOperationInfo>();
			[foreach (var op in metaCls.AllDeclaredOperations)]
			[var info = metaCls.ModelOperationInfos[op]]
			modelOperationInfos.Add([ToCSharp(op)], new __ModelOperationInfo([ToCSharp(info.OverridenOperations)], [ToCSharp(info.OverridingOperations)]));
			[end foreach]
			_modelOperationInfos = modelOperationInfos.ToImmutable();
		}

        public override __MetaModel MetaModel => [mm.Name].Instance;
        public override global::System.Type MetaType => typeof([cls.Name]);

        public override __Type? SymbolType => [if (metaCls.SymbolType is null)]null[else]typeof([ToCSharp(metaCls.SymbolType)])[end if];
        public override __ModelProperty? NameProperty => [if (metaCls.NameProperty is null)]null[else][ToCSharp(metaCls.NameProperty)][end if];
        public override __ModelProperty? TypeProperty => [if (metaCls.TypeProperty is null)]null[else][ToCSharp(metaCls.TypeProperty)][end if];
        public override global::System.Collections.Immutable.ImmutableArray<__ModelObjectInfo> BaseTypes => _baseTypes;
        public override global::System.Collections.Immutable.ImmutableArray<__ModelObjectInfo> AllBaseTypes => _allBaseTypes;
        public override global::System.Collections.Immutable.ImmutableArray<__ModelProperty> DeclaredProperties => _declaredProperties;
        public override global::System.Collections.Immutable.ImmutableArray<__ModelProperty> AllDeclaredProperties => _allDeclaredProperties;
        public override global::System.Collections.Immutable.ImmutableArray<__ModelProperty> PublicProperties => _publicProperties;
        public override global::System.Collections.Immutable.ImmutableArray<__ModelOperation> DeclaredOperations => _declaredOperations;
        public override global::System.Collections.Immutable.ImmutableArray<__ModelOperation> AllDeclaredOperations => _allDeclaredOperations;
        public override global::System.Collections.Immutable.ImmutableArray<__ModelOperation> PublicOperations => _publicOperations;

        protected override global::System.Collections.Immutable.ImmutableDictionary<string, __ModelProperty> PublicPropertiesByName => _publicPropertiesByName;
        protected override global::System.Collections.Immutable.ImmutableDictionary<__ModelProperty, __ModelPropertyInfo> ModelPropertyInfos => _modelPropertyInfos;
        protected override global::System.Collections.Immutable.ImmutableDictionary<__ModelOperation, __ModelOperationInfo> ModelOperationInfos => _modelOperationInfos;

		public override __IModelObject? Create(__Model? model = null, string? id = null)
		{
			var result = new [cls.Name]_Impl(id);
			if (model is not null) model.AddObject(result);
			return result;
		}

		public override string ToString()
		{
			return "[mm.Name].[cls.Name]Info";
		}
	}
}
end template

template GenerateCustomInterface(MetaModel mm)
internal interface ICustom[mm.Name]Implementation
{
	/// <summary>
	/// Constructor for the meta model [mm.Name]
	/// </summary>
	void [mm.Name](I[mm.Name] _this);

	[foreach (var cls in Classes)]
	/// <summary>
	/// Constructor for the class [cls.Name]
	/// </summary>
	void [cls.Name]([cls.Name] _this);

	[end foreach]

	[foreach (var cls in Classes)]
		[foreach (var prop in cls.Properties.Where(p => p.IsDerived))]
	/// <summary>
	/// Computation of the derived property [cls.Name].[prop.Name]
	/// </summary>
	[ToCSharp(prop.Type)] [cls.Name]_[prop.Name]([cls.Name] _this);

		[end foreach]
	[end foreach]

	[foreach (var cls in Classes)]
		[foreach (var op in cls.Operations)]
	/// <summary>
	/// Implementation of the operation [cls.Name].[op.Name]
	/// </summary>
	[ToCSharp(op.ReturnType)] [cls.Name]_[op.Name]([cls.Name] _this[foreach (var param in op.Parameters)], [ToCSharp(param.Type)] [param.Name][end foreach]);

		[end foreach]
	[end foreach]
}
end template

template GenerateCustomImplementation(MetaModel mm)
internal abstract class Custom[mm.Name]ImplementationBase : ICustom[mm.Name]Implementation
{
	/// <summary>
	/// Constructor for the meta model [mm.Name]
	/// </summary>
	public virtual void [mm.Name](I[mm.Name] _this)
	{
	}

	[foreach (var cls in Classes)]
	/// <summary>
	/// Constructor for the class [cls.Name]
	/// </summary>
	public virtual void [cls.Name]([cls.Name] _this)
	{
	}

	[end foreach]

	[foreach (var cls in Classes)]
		[foreach (var prop in cls.Properties.Where(p => p.IsDerived))]
	/// <summary>
	/// Computation of the derived property [cls.Name].[prop.Name]
	/// </summary>
	public abstract [ToCSharp(prop.Type)] [cls.Name]_[prop.Name]([cls.Name] _this);

		[end foreach]
	[end foreach]

	[foreach (var cls in Classes)]
		[foreach (var op in cls.Operations)]
	/// <summary>
	/// Implementation of the operation [cls.Name].[op.Name]
	/// </summary>
	public abstract [ToCSharp(op.ReturnType)] [cls.Name]_[op.Name]([cls.Name] _this[foreach (var param in op.Parameters)], [ToCSharp(param.Type)] [param.Name][end foreach]);

		[end foreach]
	[end foreach]
}
end template
