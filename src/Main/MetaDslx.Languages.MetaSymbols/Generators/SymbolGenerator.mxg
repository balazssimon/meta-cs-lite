namespace MetaDslx.Languages.MetaSymbols.Generators

using System.Linq
using MetaDslx.Languages.MetaSymbols.Model

generator SymbolGenerator

template GenerateInterface(Symbol symbol)
namespace [symbol.NamespaceName]
{
    using __ModelProperty = global::MetaDslx.CodeAnalysis.Symbols.ModelPropertyAttribute;

    [var baseTypes = symbol.BaseTypes]
    public interface [GetIntfName(symbol, symbol)]: [if (baseTypes.Count == 0)]global::MetaDslx.CodeAnalysis.Symbols.Symbol[else][from bt in baseTypes select GetIntfName(symbol, bt) separator ", "][end if]
    {
        [foreach (var prop in symbol.Properties)]
            ["["]__ModelProperty["]"]
            [GetTypeName(symbol, prop.Type)] [prop.Name] { get; }
        [end foreach]

        public static new class CompletionParts
        {
            [foreach (var phase in GetPhases(symbol))]
                public static readonly CompletionPart Start_[phase] = new CompletionPart(nameof(Start_[phase]));
                public static readonly CompletionPart Finish_[phase] = new CompletionPart(nameof(Finish_[phase]));
            [end foreach]
            public static readonly CompletionPart Start_Attribute = new CompletionPart(nameof(Start_Attribute));
            public static readonly CompletionPart Finish_Attribute = new CompletionPart(nameof(Finish_Attribute));

            public static readonly CompletionGraph CompletionGraph = 
                CompletionGraph.CreateFromParts(
                    [foreach (var phase in GetPhases(symbol))]
                        Start_[phase], Finish_[phase],
                    [end foreach]
                    Start_Attribute, Finish_Attribute
                );
        }
    }
}
end template

template GenerateBase(Symbol symbol)
    [if (symbol.BaseTypes.Count == 0)]
        [GenerateSingleBase(symbol, null)]
    [else if (symbol.BaseTypes.Count == 1)]
        [GenerateSingleBase(symbol, symbol.BaseTypes[0])]
    [else]
        [GenerateMultiBase(symbol)]
    [end if]
end template

template GenerateSingleBase(Symbol symbol, Symbol? baseSymbol)
namespace [symbol.NamespaceName].__Impl
{
    using __ISymbol = global::Microsoft.CodeAnalysis.ISymbol;
    using __Symbol = global::MetaDslx.CodeAnalysis.Symbols.Symbol;
    using __AttributeSymbol = global::MetaDslx.CodeAnalysis.Symbols.AttributeSymbol;
    using __AssemblySymbol = global::MetaDslx.CodeAnalysis.Symbols.AssemblySymbol;
    using __ModuleSymbol = global::MetaDslx.CodeAnalysis.Symbols.ModuleSymbol;
    using __DeclarationSymbol = global::MetaDslx.CodeAnalysis.Symbols.DeclarationSymbol;
    using __NamespaceSymbol = global::MetaDslx.CodeAnalysis.Symbols.NamespaceSymbol;
    using __TypeSymbol = global::MetaDslx.CodeAnalysis.Symbols.TypeSymbol;
    using __ISymbolFactory = global::MetaDslx.CodeAnalysis.Symbols.ISymbolFactory;
    using __LexicalSortKey = global::MetaDslx.CodeAnalysis.Symbols.LexicalSortKey;
    using __IModelObject = global::MetaDslx.Modeling.IModelObject;
    using __ErrorSymbolInfo = global::MetaDslx.CodeAnalysis.Symbols.ErrorSymbolInfo;
    using __ModelProperty = global::MetaDslx.CodeAnalysis.Symbols.ModelPropertyAttribute;
    using __CompletionGraph = global::MetaDslx.CodeAnalysis.Symbols.CompletionGraph;
    using __CompletionPart = global::MetaDslx.CodeAnalysis.Symbols.CompletionPart;
    using __MergedDeclaration = global::MetaDslx.CodeAnalysis.Declarations.MergedDeclaration;
    using __DiagnosticBag = global::MetaDslx.CodeAnalysis.DiagnosticBag;
    using __Compilation = global::MetaDslx.CodeAnalysis.Compilation;
    using __SourceLocation = global::MetaDslx.CodeAnalysis.SourceLocation;
    using __CancellationToken = global::System.Threading.CancellationToken;
    using __IObjectPool = global::MetaDslx.CodeAnalysis.PooledObjects.IObjectPool;
    using __ObjectPool = global::MetaDslx.CodeAnalysis.PooledObjects.ObjectPool<[GetImplName(symbol, symbol)]>;
    using __NotImplementedException = global::System.NotImplementedException;
    using __CultureInfo = global::System.Globalization.CultureInfo;
    using __ImmutableAttributeSymbols = global::System.Collections.Immutable.ImmutableArray<global::MetaDslx.CodeAnalysis.Symbols.AttributeSymbol>;

    public partial class [GetInstName(symbol, symbol)] : [if (baseSymbol is null)]global::MetaDslx.CodeAnalysis.Symbols.SymbolInst[else][GetInstName(symbol, baseSymbol)][end if], [GetIntfName(symbol, symbol)]
    {
        [foreach (var prop in symbol.Properties)]
            [if (prop.IsWeak)]
                private static [GetFieldType(symbol, prop)] [GetFieldName(prop)] = new [GetFieldType(symbol, prop)]();
            [else]
                private [GetFieldType(symbol, prop)] [GetFieldName(prop)];
            [end if]
        [end foreach]

        public [GetInstName(symbol, symbol)](__Symbol container, __MergedDeclaration declaration, __IModelObject modelObject) 
            : base(container, declaration, modelObject)
        {
        }

        public [GetInstName(symbol, symbol)](__Symbol container, __IModelObject modelObject) 
            : base(container, modelObject)
        {
        }

        public [GetInstName(symbol, symbol)](__Symbol container, __ISymbol csharpSymbol) 
            : base(container, csharpSymbol)
        {
        }

        public [GetInstName(symbol, symbol)](__Symbol container, __ErrorSymbolInfo errorInfo) 
            : base(container, errorInfo)
        {
        }

        public [GetInstName(symbol, symbol)](__Symbol container, __MergedDeclaration declaration, __IModelObject modelObject, string? name, string? metadataName, __ImmutableAttributeSymbols attributes[foreach (var prop in GetProperties(symbol))], [GetTypeName(symbol, prop.Type)] [GetParamName(prop)][end foreach]) 
            : base(container, declaration, modelObject, name, metadataName, attributes[foreach (var prop in GetProperties(baseSymbol))], [GetParamName(prop)][end foreach])
        {
            [foreach (var prop in symbol.Properties)]
                [AssignProperty(symbol, prop, GetParamName(prop))]
            [end foreach]
        }

        public [GetInstName(symbol, symbol)](__Symbol container, __IModelObject modelObject, string? name, string? metadataName, __ImmutableAttributeSymbols attributes[foreach (var prop in GetProperties(symbol))], [GetTypeName(symbol, prop.Type)] [GetParamName(prop)][end foreach]) 
            : base(container, modelObject, name, metadataName, attributes[foreach (var prop in GetProperties(baseSymbol))], [GetParamName(prop)][end foreach])
        {
            [foreach (var prop in symbol.Properties)]
                [AssignProperty(symbol, prop, GetParamName(prop))]
            [end foreach]
        }

        public [GetInstName(symbol, symbol)](__Symbol container, __ISymbol csharpSymbol, string? name, string? metadataName, __ImmutableAttributeSymbols attributes[foreach (var prop in GetProperties(symbol))], [GetTypeName(symbol, prop.Type)] [GetParamName(prop)][end foreach]) 
            : base(container, csharpSymbol, name, metadataName, attributes[foreach (var prop in GetProperties(baseSymbol))], [GetParamName(prop)][end foreach])
        {
            [foreach (var prop in symbol.Properties)]
                [AssignProperty(symbol, prop, GetParamName(prop))]
            [end foreach]
        }

        public [GetInstName(symbol, symbol)](__Symbol container, __Compilation compilation, __IModelObject? modelObject, string? name, string? metadataName, __ImmutableAttributeSymbols attributes[foreach (var prop in GetProperties(symbol))], [GetTypeName(symbol, prop.Type)] [GetParamName(prop)][end foreach]) 
            : base(container, compilation, modelObject, name, metadataName, attributes[foreach (var prop in GetProperties(baseSymbol))], [GetParamName(prop)][end foreach])
        {
            [foreach (var prop in symbol.Properties)]
                [AssignProperty(symbol, prop, GetParamName(prop))]
            [end foreach]
        }

        public override __ISymbolFactory SymbolFactory
        {
            get
            {
                var impl = [GetImplName(symbol, symbol)].GetInstance(this);
                var result = impl.SymbolFactory;
                impl.Free();
                return result;
            }
        }

        public override __AssemblySymbol? ContainingAssembly
        {
            get
            {
                var impl = [GetImplName(symbol, symbol)].GetInstance(this);
                var result = impl.ContainingAssembly;
                impl.Free();
                return result;
            }
        }

        public override __Compilation? DeclaringCompilation
        {
            get
            {
                var impl = [GetImplName(symbol, symbol)].GetInstance(this);
                var result = impl.DeclaringCompilation;
                impl.Free();
                return result;
            }
        }

        public override __ModuleSymbol? ContainingModule
        {
            get
            {
                var impl = [GetImplName(symbol, symbol)].GetInstance(this);
                var result = impl.ContainingModule;
                impl.Free();
                return result;
            }
        }

        public override __DeclarationSymbol? ContainingDeclaration
        {
            get
            {
                var impl = [GetImplName(symbol, symbol)].GetInstance(this);
                var result = impl.ContainingDeclaration;
                impl.Free();
                return result;
            }
        }

        public override __TypeSymbol? ContainingType
        {
            get
            {
                var impl = [GetImplName(symbol, symbol)].GetInstance(this);
                var result = impl.ContainingType;
                impl.Free();
                return result;
            }
        }

        public override __NamespaceSymbol? ContainingNamespace
        {
            get
            {
                var impl = [GetImplName(symbol, symbol)].GetInstance(this);
                var result = impl.ContainingNamespace;
                impl.Free();
                return result;
            }
        }

        public override __LexicalSortKey GetLexicalSortKey()
        {
            var impl = [GetImplName(symbol, symbol)].GetInstance(this);
            var result = impl.GetLexicalSortKey();
            impl.Free();
            return result;
        }

        public override bool HasUnsupportedMetadata
        {
            get
            {
                var impl = [GetImplName(symbol, symbol)].GetInstance(this);
                var result = impl.HasUnsupportedMetadata;
                impl.Free();
                return result;
            }
        }

        public override string GetDocumentationCommentId()
        {
            var impl = [GetImplName(symbol, symbol)].GetInstance(this);
            var result = impl.GetDocumentationCommentId();
            impl.Free();
            return result;
        }

        public override string GetDocumentationCommentXml(__CultureInfo preferredCulture = null, bool expandIncludes = false, __CancellationToken cancellationToken = default)
        {
            var impl = [GetImplName(symbol, symbol)].GetInstance(this);
            var result = impl.GetDocumentationCommentXml(preferredCulture, expandIncludes, cancellationToken);
            impl.Free();
            return result;
        }

        [foreach (var prop in symbol.Properties)]

            public [GetTypeName(symbol, prop.Type)] [prop.Name]
            {
                get
                {
                    this.ForceComplete([GetIntfName(symbol, symbol)].CompletionParts.Finish_[prop.Name], null, default);
                    [if (prop.IsWeak)]
                        if ([GetFieldName(prop)].TryGetValue(this, out var result)) return ([GetTypeName(symbol, prop.Type)])result;
                        else return [GetDefaultValue(symbol, prop)];
                    [else]
                        return [GetFieldName(prop)];
                    [end if]
                }
            }
        [end foreach]

        protected override bool ForceCompletePart(ref __CompletionPart incompletePart, __SourceLocation? locationOpt, __CancellationToken cancellationToken)
        {
            [var hasNewPhase = false]
            [var phases = GetPhases(symbol)]
            [var basePhases = GetPhases(baseSymbol)]
            [foreach (var phase in phases)]
                [if (!basePhases.Contains(phase))]
                    [hasNewPhase = true;]
                    [var props = GetPhaseProperties(symbol, phase)]
                    if (incompletePart == [GetIntfName(symbol, symbol)].CompletionParts.Start_[phase] || incompletePart == [GetIntfName(symbol, symbol)].CompletionParts.Finish_[phase])
                    {
                        if (NotePartComplete([GetIntfName(symbol, symbol)].CompletionParts.Start_[phase]))
                        {
                            var diagnostics = __DiagnosticBag.GetInstance();
                            [if (props.Length >= 2)]
                                var result = Complete_[phase](diagnostics, cancellationToken);
                                [foreach (var prop in props)]
                                    [AssignProperty(symbol, prop, "result."+prop.Name)]
                                [end foreach]
                            [else if (props.Length == 1)]
                                var result = Complete_[phase](diagnostics, cancellationToken);
                                [AssignProperty(symbol, props[0], "result")]
                            [else]
                                Complete_[phase](diagnostics, cancellationToken);
                            [end if]
                            AddSymbolDiagnostics(diagnostics);
                            diagnostics.Free();
                            NotePartComplete([GetIntfName(symbol, symbol)].CompletionParts.Finish_[phase]);
                        }
                        return true;
                    }
                    else [\]
                [end if]
            [end foreach]
            [if (hasNewPhase)]
                {
                    return base.ForceCompletePart(ref incompletePart, locationOpt, cancellationToken);
                }
            [else]
                return base.ForceCompletePart(ref incompletePart, locationOpt, cancellationToken);
            [end if]
        }


        protected override void CompletePart_Initialize(__DiagnosticBag diagnostics, __CancellationToken cancellationToken)
        {
            var impl = [GetImplName(symbol, symbol)].GetInstance(this);
            impl.CompletePart_Initialize(diagnostics, cancellationToken);
            impl.Free();
        }

        protected override string? Complete_Name(__DiagnosticBag diagnostics, __CancellationToken cancellationToken)
        {
            var impl = [GetImplName(symbol, symbol)].GetInstance(this);
            var result = impl.Complete_Name(diagnostics, cancellationToken);
            impl.Free();
            return result;
        }

        protected override string? Complete_MetadataName(__DiagnosticBag diagnostics, __CancellationToken cancellationToken)
        {
            var impl = [GetImplName(symbol, symbol)].GetInstance(this);
            var result = impl.Complete_MetadataName(diagnostics, cancellationToken);
            impl.Free();
            return result;
        }

        protected override global::System.Collections.Immutable.ImmutableArray<__Symbol> CompletePart_CreateContainedSymbols(__DiagnosticBag diagnostics, __CancellationToken cancellationToken)
        {
            var impl = [GetImplName(symbol, symbol)].GetInstance(this);
            var result = impl.CompletePart_CreateContainedSymbols(diagnostics, cancellationToken);
            impl.Free();
            return result;
        }

        protected override global::System.Collections.Immutable.ImmutableArray<__AttributeSymbol> Complete_Attributes(__DiagnosticBag diagnostics, __CancellationToken cancellationToken)
        {
            var impl = [GetImplName(symbol, symbol)].GetInstance(this);
            var result = impl.Complete_Attributes(diagnostics, cancellationToken);
            impl.Free();
            return result;
        }

        protected override void CompletePart_ComputeNonSymbolProperties(__DiagnosticBag diagnostics, __CancellationToken cancellationToken)
        {
            var impl = [GetImplName(symbol, symbol)].GetInstance(this);
            impl.CompletePart_ComputeNonSymbolProperties(diagnostics, cancellationToken);
            impl.Free();
        }

        protected override void CompletePart_Finalize(__DiagnosticBag diagnostics, __CancellationToken cancellationToken)
        {
            var impl = [GetImplName(symbol, symbol)].GetInstance(this);
            impl.CompletePart_Finalize(diagnostics, cancellationToken);
            impl.Free();
        }

        protected override void CompletePart_Validate(__DiagnosticBag diagnostics, __CancellationToken cancellationToken)
        {
            var impl = [GetImplName(symbol, symbol)].GetInstance(this);
            impl.CompletePart_Validate(diagnostics, cancellationToken);
            impl.Free();
        }

        [foreach (var phase in GetPhases(symbol))]

            [var virtOvrd = basePhases.Contains(phase) ? "override" : "virtual"]
            [var props = GetPhaseProperties(symbol, phase)]
            [if (props.Length >= 2)]
                protected [virtOvrd] ([from prop in props select GetTypeName(symbol, prop.Type) separator ", "]) Complete_[phase](__DiagnosticBag diagnostics, __CancellationToken cancellationToken)
                {
                    var impl = [GetImplName(symbol, symbol)].GetInstance(this);
                    var result = impl.Complete_[phase](diagnostics, cancellationToken);
                    impl.Free();
                    return result;
                }
            [else if (props.Length == 1)]
                [var prop = props[0]]
                protected [virtOvrd] [GetTypeName(symbol, prop.Type)] Complete_[phase](__DiagnosticBag diagnostics, __CancellationToken cancellationToken)
                {
                    var impl = [GetImplName(symbol, symbol)].GetInstance(this);
                    var result = impl.Complete_[phase](diagnostics, cancellationToken);
                    impl.Free();
                    return result;
                }
            [else]
                protected [virtOvrd] void Complete_[phase](__DiagnosticBag diagnostics, __CancellationToken cancellationToken)
                {
                    var impl = [GetImplName(symbol, symbol)].GetInstance(this);
                    impl.Complete_[phase](diagnostics, cancellationToken);
                    impl.Free();
                }
            [end if]
        [end foreach]
    }

    public abstract class [GetBaseName(symbol, symbol)] : [if (baseSymbol is null)]global::MetaDslx.CodeAnalysis.Symbols.SymbolImpl[else][GetImplName(symbol, baseSymbol)][end if], [GetIntfName(symbol, symbol)]
    {
        protected [GetBaseName(symbol, symbol)](__IObjectPool pool) 
            : base(pool)
        {
        }

        [foreach (var prop in symbol.Properties)]
            public [GetTypeName(symbol, prop.Type)] [prop.Name] => (([GetIntfName(symbol, symbol)])__Wrapped).[prop.Name];
        [end foreach]

        [foreach (var phase in phases)]
            [if (!basePhases.Contains(phase))]

                [var props = GetPhaseProperties(symbol, phase)]
                [if (props.Length >= 2)]
                    [if (props.Where(p => p.IsDerived).Any())]
                        public abstract ([from prop in props select GetTypeName(symbol, prop.Type) separator ", "]) Complete_[phase](__DiagnosticBag diagnostics, __CancellationToken cancellationToken);
                    [else]
                        public virtual ([from prop in props select GetTypeName(symbol, prop.Type) separator ", "]) Complete_[phase](__DiagnosticBag diagnostics, __CancellationToken cancellationToken)
                        {
                            // TODO
                            return ([from prop in props select GetDefaultValue(symbol, prop) separator ", "]);
                        }
                    [end if]
                [else if (props.Length == 1)]
                    [var prop = props[0]]
                    [if (prop.IsDerived)]
                        public abstract [GetTypeName(symbol, prop.Type)] Complete_[phase](__DiagnosticBag diagnostics, __CancellationToken cancellationToken);
                    [else]
                        public virtual [GetTypeName(symbol, prop.Type)] Complete_[phase](__DiagnosticBag diagnostics, __CancellationToken cancellationToken)
                        {
                            // TODO
                            return [GetDefaultValue(symbol, prop)];
                        }
                    [end if]
                [else]
                    public abstract void Complete_[phase](__DiagnosticBag diagnostics, __CancellationToken cancellationToken);
                [end if]
            [end if]
        [end foreach]
    }

    public partial class [GetImplName(symbol, symbol)] : [GetBaseName(symbol, symbol)]
    {
        private static readonly __ObjectPool s_poolInstance = new __ObjectPool(() => new [GetImplName(symbol, symbol)](s_poolInstance), 32);

        protected [GetImplName(symbol, symbol)](__IObjectPool pool) 
            : base(pool)
        {
        }

        public static new [GetImplName(symbol, symbol)] GetInstance([GetIntfName(symbol, symbol)] wrapped)
        {
            var result = s_poolInstance.Allocate();
            global::System.Diagnostics.Debug.Assert(result.__Wrapped is null);
            result.__InitWrapped(wrapped);
            return result;
        }
    }
}
end template

template GenerateMultiBase(Symbol symbol)
namespace [symbol.NamespaceName].__Impl
{
    using __ISymbol = global::Microsoft.CodeAnalysis.ISymbol;
    using __IModelObject = global::MetaDslx.Modeling.IModelObject;
    using __MergedDeclaration = global::MetaDslx.CodeAnalysis.Declarations.MergedDeclaration;
    using __Symbol = global::MetaDslx.CodeAnalysis.Symbols.Symbol;
    using __ErrorSymbolInfo = global::MetaDslx.CodeAnalysis.Symbols.ErrorSymbolInfo;
    using __ModelProperty = global::MetaDslx.CodeAnalysis.Symbols.ModelPropertyAttribute;
    using __CompletionGraph = global::MetaDslx.CodeAnalysis.Symbols.CompletionGraph;
    using __CompletionPart = global::MetaDslx.CodeAnalysis.Symbols.CompletionPart;
    using __DiagnosticBag = global::MetaDslx.CodeAnalysis.DiagnosticBag;
    using __SourceLocation = global::MetaDslx.CodeAnalysis.SourceLocation;
    using __CancellationToken = global::System.Threading.CancellationToken;
    using __ObjectPool = global::MetaDslx.CodeAnalysis.PooledObjects.ObjectPool<[GetImplName(symbol, symbol)]>;
    using __NotImplementedException = global::System.NotImplementedException;
    using __ImmutableAttributeSymbols = global::System.Collections.Immutable.ImmutableArray<global::MetaDslx.CodeAnalysis.Symbols.AttributeSymbol>;

    public partial class [GetInstName(symbol, symbol)] : global::MetaDslx.CodeAnalysis.Symbols.SymbolInst, [GetIntfName(symbol, symbol)]
    {
        [foreach (var prop in GetProperties(symbol))]
            [if (prop.IsWeak)]
                private static [GetFieldType(symbol, prop)] [GetFieldName(prop)] = new [GetFieldType(symbol, prop)]();
            [else]
                private [GetFieldType(symbol, prop)] [GetFieldName(prop)];
            [end if]
        [end foreach]
        // TODO
    }
}
end template

template GenerateImplementation(Symbol symbol)
using System.Threading;
using System.Collections.Immutable;
using MetaDslx.Modeling;
using MetaDslx.CodeAnalysis;
using MetaDslx.CodeAnalysis.Declarations;
using MetaDslx.CodeAnalysis.Symbols;

namespace [symbol.NamespaceName].__Impl
{
    public partial class [GetImplName(symbol, symbol)]
    {
    }
}
end template

template AssignProperty(Symbol symbol, Property prop, string variable)
    [if (prop.IsWeak)]
        [if (prop.Type.Dimensions > 0)]
            if (![variable].IsDefaultOrEmpty)
            {
                [GetFieldName(prop)].Add(this, [variable]);
            }
        [else]
            if ([variable] != [GetDefaultValue(symbol, prop)])
            {
                [GetFieldName(prop)].Add(this, [variable]);
            }
        [end if]
    [else]
        [GetFieldName(prop)] = [variable];
    [end if]
end template

