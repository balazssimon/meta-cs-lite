namespace MetaDslx.Languages.MetaSymbols.Generators

using System.Linq
using MetaDslx.Languages.MetaSymbols.Model

generator SymbolGenerator

template GenerateInterface(Symbol symbol)
namespace [symbol.NamespaceName]
{
    using __ModelProperty = global::MetaDslx.CodeAnalysis.Symbols.ModelPropertyAttribute;

    [var baseTypes = symbol.BaseTypes]
    public interface [GetIntfName(symbol, symbol)]: [if (baseTypes.Count == 0)]global::MetaDslx.CodeAnalysis.Symbols.Symbol[else][from bt in baseTypes select GetIntfName(symbol, bt) separator ", "][end if]
    {
        [foreach (var prop in symbol.Properties)]
            ["["]__ModelProperty["]"]
            [GetTypeName(symbol, prop.Type)] [prop.Name] { get; }
        [end foreach]

        public static new class CompletionParts
        {
            [foreach (var phase in GetPhases(symbol))]
                public static readonly CompletionPart Start_[phase] = new CompletionPart(nameof(Start_[phase]));
                public static readonly CompletionPart Finish_[phase] = new CompletionPart(nameof(Finish_[phase]));
            [end foreach]
            public static readonly CompletionPart Start_Attribute = new CompletionPart(nameof(Start_Attribute));
            public static readonly CompletionPart Finish_Attribute = new CompletionPart(nameof(Finish_Attribute));

            public static readonly CompletionGraph CompletionGraph = 
                CompletionGraph.CreateFromParts(
                    [foreach (var phase in GetPhases(symbol))]
                        Start_[phase], Finish_[phase],
                    [end foreach]
                    Start_Attribute, Finish_Attribute
                );
        }
    }
}
end template

template GenerateBase(Symbol symbol)
    [if (symbol.BaseTypes.Count == 0)]
        [GenerateSingleBase(symbol, null)]
    [else if (symbol.BaseTypes.Count == 1)]
        [GenerateSingleBase(symbol, symbol.BaseTypes[0])]
    [else]
        [GenerateMultiBase(symbol)]
    [end if]
end template

template GenerateSingleBase(Symbol symbol, Symbol? baseSymbol)
namespace [symbol.NamespaceName].__Impl
{
    using __ISymbol = global::Microsoft.CodeAnalysis.ISymbol;
    using __Symbol = global::MetaDslx.CodeAnalysis.Symbols.Symbol;
    using __AttributeSymbol = global::MetaDslx.CodeAnalysis.Symbols.AttributeSymbol;
    using __AssemblySymbol = global::MetaDslx.CodeAnalysis.Symbols.AssemblySymbol;
    using __ModuleSymbol = global::MetaDslx.CodeAnalysis.Symbols.ModuleSymbol;
    using __DeclarationSymbol = global::MetaDslx.CodeAnalysis.Symbols.DeclarationSymbol;
    using __NamespaceSymbol = global::MetaDslx.CodeAnalysis.Symbols.NamespaceSymbol;
    using __TypeSymbol = global::MetaDslx.CodeAnalysis.Symbols.TypeSymbol;
    using __ISymbolFactory = global::MetaDslx.CodeAnalysis.Symbols.ISymbolFactory;
    using __LexicalSortKey = global::MetaDslx.CodeAnalysis.Symbols.LexicalSortKey;
    using __IModelObject = global::MetaDslx.Modeling.IModelObject;
    using __ErrorSymbolInfo = global::MetaDslx.CodeAnalysis.Symbols.ErrorSymbolInfo;
    using __ModelProperty = global::MetaDslx.CodeAnalysis.Symbols.ModelPropertyAttribute;
    using __CompletionGraph = global::MetaDslx.CodeAnalysis.Symbols.CompletionGraph;
    using __CompletionPart = global::MetaDslx.CodeAnalysis.Symbols.CompletionPart;
    using __MergedDeclaration = global::MetaDslx.CodeAnalysis.Declarations.MergedDeclaration;
    using __DiagnosticBag = global::MetaDslx.CodeAnalysis.DiagnosticBag;
    using __Compilation = global::MetaDslx.CodeAnalysis.Compilation;
    using __SourceLocation = global::MetaDslx.CodeAnalysis.SourceLocation;
    using __CancellationToken = global::System.Threading.CancellationToken;
    using __NotImplementedException = global::System.NotImplementedException;
    using __CultureInfo = global::System.Globalization.CultureInfo;
    using __ImmutableAttributeSymbols = global::System.Collections.Immutable.ImmutableArray<global::MetaDslx.CodeAnalysis.Symbols.AttributeSymbol>;

    public partial class [GetInstName(symbol, symbol)] : [if (baseSymbol is null)]global::MetaDslx.CodeAnalysis.Symbols.SymbolInst[else][GetInstName(symbol, baseSymbol)][end if], [GetIntfName(symbol, symbol)]
    {
        [foreach (var prop in symbol.Properties)]
            [if (prop.IsWeak)]
                private static [GetFieldType(symbol, prop)] [GetFieldName(prop)] = new [GetFieldType(symbol, prop)]();
            [else]
                private [GetFieldType(symbol, prop)] [GetFieldName(prop)];
            [end if]
        [end foreach]

        public [GetInstName(symbol, symbol)](__Symbol container, __MergedDeclaration declaration, __IModelObject modelObject) 
            : base(container, declaration, modelObject)
        {
        }

        public [GetInstName(symbol, symbol)](__Symbol container, __IModelObject modelObject) 
            : base(container, modelObject)
        {
        }

        public [GetInstName(symbol, symbol)](__Symbol container, __ISymbol csharpSymbol) 
            : base(container, csharpSymbol)
        {
        }

        public [GetInstName(symbol, symbol)](__Symbol container, __ErrorSymbolInfo errorInfo) 
            : base(container, errorInfo)
        {
        }

        public [GetInstName(symbol, symbol)](__Symbol container, __MergedDeclaration declaration, __IModelObject modelObject, string? name, string? metadataName, __ImmutableAttributeSymbols attributes[foreach (var prop in GetProperties(symbol))], [GetTypeName(symbol, prop.Type)] [GetParamName(prop)][end foreach]) 
            : base(container, declaration, modelObject, name, metadataName, attributes[foreach (var prop in GetProperties(baseSymbol))], [GetParamName(prop)][end foreach])
        {
            [foreach (var prop in symbol.Properties)]
                [AssignProperty(symbol, prop, GetParamName(prop))]
            [end foreach]
        }

        public [GetInstName(symbol, symbol)](__Symbol container, __IModelObject modelObject, string? name, string? metadataName, __ImmutableAttributeSymbols attributes[foreach (var prop in GetProperties(symbol))], [GetTypeName(symbol, prop.Type)] [GetParamName(prop)][end foreach]) 
            : base(container, modelObject, name, metadataName, attributes[foreach (var prop in GetProperties(baseSymbol))], [GetParamName(prop)][end foreach])
        {
            [foreach (var prop in symbol.Properties)]
                [AssignProperty(symbol, prop, GetParamName(prop))]
            [end foreach]
        }

        public [GetInstName(symbol, symbol)](__Symbol container, __ISymbol csharpSymbol, string? name, string? metadataName, __ImmutableAttributeSymbols attributes[foreach (var prop in GetProperties(symbol))], [GetTypeName(symbol, prop.Type)] [GetParamName(prop)][end foreach]) 
            : base(container, csharpSymbol, name, metadataName, attributes[foreach (var prop in GetProperties(baseSymbol))], [GetParamName(prop)][end foreach])
        {
            [foreach (var prop in symbol.Properties)]
                [AssignProperty(symbol, prop, GetParamName(prop))]
            [end foreach]
        }

        public [GetInstName(symbol, symbol)](__Symbol container, __Compilation compilation, __IModelObject? modelObject, string? name, string? metadataName, __ImmutableAttributeSymbols attributes[foreach (var prop in GetProperties(symbol))], [GetTypeName(symbol, prop.Type)] [GetParamName(prop)][end foreach]) 
            : base(container, compilation, modelObject, name, metadataName, attributes[foreach (var prop in GetProperties(baseSymbol))], [GetParamName(prop)][end foreach])
        {
            [foreach (var prop in symbol.Properties)]
                [AssignProperty(symbol, prop, GetParamName(prop))]
            [end foreach]
        }

        public override __ISymbolFactory SymbolFactory => [CallImpl(symbol, "__ISymbolFactory", "SymbolFactory")];

        public override __AssemblySymbol? ContainingAssembly => [CallImpl(symbol, "__AssemblySymbol", "ContainingAssembly")];

        public override __Compilation? DeclaringCompilation => [CallImpl(symbol, "__Compilation", "DeclaringCompilation")];

        public override __ModuleSymbol? ContainingModule => [CallImpl(symbol, "__ModuleSymbol", "ContainingModule")];

        public override __DeclarationSymbol? ContainingDeclaration => [CallImpl(symbol, "__DeclarationSymbol", "ContainingDeclaration")];

        public override __TypeSymbol? ContainingType => [CallImpl(symbol, "__TypeSymbol", "ContainingType")];

        public override __NamespaceSymbol? ContainingNamespace => [CallImpl(symbol, "__NamespaceSymbol", "ContainingNamespace")];

        public override __LexicalSortKey GetLexicalSortKey()
        {
            return [CallImpl(symbol, "__LexicalSortKey", "GetLexicalSortKey()")];
        }

        public override bool HasUnsupportedMetadata => [CallImpl(symbol, "bool", "HasUnsupportedMetadata")];

        public override string GetDocumentationCommentId()
        {
            return [CallImpl(symbol, "string", "GetDocumentationCommentId()")];
        }

        public override string GetDocumentationCommentXml(__CultureInfo preferredCulture = null, bool expandIncludes = false, __CancellationToken cancellationToken = default)
        {
            return [CallImpl(symbol, "string", "GetDocumentationCommentXml(preferredCulture, expandIncludes, cancellationToken)")];
        }

        [foreach (var prop in symbol.Properties)]

            public [GetTypeName(symbol, prop.Type)] [prop.Name]
            {
                get
                {
                    this.ForceComplete([GetIntfName(symbol, symbol)].CompletionParts.Finish_[prop.Phase?.Name ?? prop.Name], null, default);
                    [if (prop.IsWeak)]
                        if ([GetFieldName(prop)].TryGetValue(this, out var result)) return ([GetTypeName(symbol, prop.Type)])result;
                        else return [GetDefaultValue(symbol, prop)];
                    [else]
                        return [GetFieldName(prop)];
                    [end if]
                }
            }
        [end foreach]

        protected override bool ForceCompletePart(ref __CompletionPart incompletePart, __SourceLocation? locationOpt, __CancellationToken cancellationToken)
        {
            [var hasNewPhase = false]
            [var phases = GetPhases(symbol)]
            [var basePhases = GetPhases(baseSymbol)]
            [foreach (var phase in phases)]
                [if (!basePhases.Contains(phase))]
                    [hasNewPhase = true;]
                    [var props = GetPhaseProperties(symbol, phase)]
                    if (incompletePart == [GetIntfName(symbol, symbol)].CompletionParts.Start_[phase] || incompletePart == [GetIntfName(symbol, symbol)].CompletionParts.Finish_[phase])
                    {
                        if (NotePartComplete([GetIntfName(symbol, symbol)].CompletionParts.Start_[phase]))
                        {
                            var diagnostics = __DiagnosticBag.GetInstance();
                            [if (props.Length >= 2)]
                                var result = Complete_[phase](diagnostics, cancellationToken);
                                [foreach (var prop in props)]
                                    [AssignProperty(symbol, prop, "result."+prop.Name)]
                                [end foreach]
                            [else if (props.Length == 1)]
                                var result = Complete_[phase](diagnostics, cancellationToken);
                                [AssignProperty(symbol, props[0], "result")]
                            [else]
                                Complete_[phase](diagnostics, cancellationToken);
                            [end if]
                            AddSymbolDiagnostics(diagnostics);
                            diagnostics.Free();
                            NotePartComplete([GetIntfName(symbol, symbol)].CompletionParts.Finish_[phase]);
                        }
                        return true;
                    }
                    else [\]
                [end if]
            [end foreach]
            [if (hasNewPhase)]
                {
                    return base.ForceCompletePart(ref incompletePart, locationOpt, cancellationToken);
                }
            [else]
                return base.ForceCompletePart(ref incompletePart, locationOpt, cancellationToken);
            [end if]
        }


        protected override void CompletePart_Initialize(__DiagnosticBag diagnostics, __CancellationToken cancellationToken)
        {
            [CallImpl(symbol, "CompletePart_Initialize(diagnostics, cancellationToken)")];
        }

        protected override string? Complete_Name(__DiagnosticBag diagnostics, __CancellationToken cancellationToken)
        {
            return [CallImpl(symbol, "string?", "Complete_Name(diagnostics, cancellationToken)")];
        }

        protected override string? Complete_MetadataName(__DiagnosticBag diagnostics, __CancellationToken cancellationToken)
        {
            return [CallImpl(symbol, "string?", "Complete_MetadataName(diagnostics, cancellationToken)")];
        }

        protected override global::System.Collections.Immutable.ImmutableArray<__Symbol> CompletePart_CreateContainedSymbols(__DiagnosticBag diagnostics, __CancellationToken cancellationToken)
        {
            return [CallImpl(symbol, "global::System.Collections.Immutable.ImmutableArray<__Symbol>", "CompletePart_CreateContainedSymbols(diagnostics, cancellationToken)")];
        }

        protected override global::System.Collections.Immutable.ImmutableArray<__AttributeSymbol> Complete_Attributes(__DiagnosticBag diagnostics, __CancellationToken cancellationToken)
        {
            return [CallImpl(symbol, "global::System.Collections.Immutable.ImmutableArray<__AttributeSymbol>", "Complete_Attributes(diagnostics, cancellationToken)")];
        }

        protected override void CompletePart_ComputeNonSymbolProperties(__DiagnosticBag diagnostics, __CancellationToken cancellationToken)
        {
            [CallImpl(symbol, "CompletePart_ComputeNonSymbolProperties(diagnostics, cancellationToken)")];
        }

        protected override void CompletePart_Finalize(__DiagnosticBag diagnostics, __CancellationToken cancellationToken)
        {
            [CallImpl(symbol, "CompletePart_Finalize(diagnostics, cancellationToken)")];
        }

        protected override void CompletePart_Validate(__DiagnosticBag diagnostics, __CancellationToken cancellationToken)
        {
            [CallImpl(symbol, "CompletePart_Validate(diagnostics, cancellationToken)")];
        }

        [foreach (var phase in GetPhases(symbol))]

            [var virtOvrd = basePhases.Contains(phase) ? "override" : "virtual"]
            [var props = GetPhaseProperties(symbol, phase)]
            [if (props.Length >= 2)]
                [var returnType = "("+string.Join(", ", props.Select(p => GetTypeName(symbol, p.Type)+" "+p.Name))+")"]
                protected [virtOvrd] [returnType] Complete_[phase](__DiagnosticBag diagnostics, __CancellationToken cancellationToken)
                {
                    return [CallImpl(symbol, returnType, "Complete_"+phase+"(diagnostics, cancellationToken)")];
                }
            [else if (props.Length == 1)]
                [var prop = props[0]]
                [var returnType = GetTypeName(symbol, prop.Type)]
                protected [virtOvrd] [returnType] Complete_[phase](__DiagnosticBag diagnostics, __CancellationToken cancellationToken)
                {
                    return [CallImpl(symbol, returnType, "Complete_"+phase+"(diagnostics, cancellationToken)")];
                }
            [else]
                protected [virtOvrd] void Complete_[phase](__DiagnosticBag diagnostics, __CancellationToken cancellationToken)
                {
                    [CallImpl(symbol, "Complete_"+phase+"(diagnostics, cancellationToken)")];
                }
            [end if]
        [end foreach]
    }

    public abstract class [GetBaseName(symbol, symbol)] : [if (baseSymbol is null)]global::MetaDslx.CodeAnalysis.Symbols.SymbolImpl[else][GetImplName(symbol, baseSymbol)][end if], [GetIntfName(symbol, symbol)]
    {
        [foreach (var prop in symbol.Properties)]
            public [GetTypeName(symbol, prop.Type)] [prop.Name] => (([GetIntfName(symbol, symbol)])__Wrapped).[prop.Name];
        [end foreach]

        [foreach (var phase in phases)]
            [if (!basePhases.Contains(phase))]

                [var props = GetPhaseProperties(symbol, phase)]
                [if (props.Length >= 2)]
                    [var returnType = "("+string.Join(", ", props.Select(p => GetTypeName(symbol, p.Type)+" "+p.Name))+")"]
                    [if (props.Where(p => p.IsDerived).Any())]
                        public abstract [returnType] Complete_[phase](__DiagnosticBag diagnostics, __CancellationToken cancellationToken);
                    [else]
                        public virtual [returnType] Complete_[phase](__DiagnosticBag diagnostics, __CancellationToken cancellationToken)
                        {
                            // TODO
                            return ([from prop in props select GetDefaultValue(symbol, prop) separator ", "]);
                        }
                    [end if]
                [else if (props.Length == 1)]
                    [var prop = props[0]]
                    [var returnType = GetTypeName(symbol, prop.Type)]
                    [if (prop.IsDerived)]
                        public abstract [returnType] Complete_[phase](__DiagnosticBag diagnostics, __CancellationToken cancellationToken);
                    [else]
                        public virtual [returnType] Complete_[phase](__DiagnosticBag diagnostics, __CancellationToken cancellationToken)
                        {
                            // TODO
                            return [GetDefaultValue(symbol, prop)];
                        }
                    [end if]
                [else]
                    public abstract void Complete_[phase](__DiagnosticBag diagnostics, __CancellationToken cancellationToken);
                [end if]
            [end if]
        [end foreach]
    }
}
end template

template GenerateMultiBase(Symbol symbol)
namespace [symbol.NamespaceName].__Impl
{
    using __ISymbol = global::Microsoft.CodeAnalysis.ISymbol;
    using __IModelObject = global::MetaDslx.Modeling.IModelObject;
    using __MergedDeclaration = global::MetaDslx.CodeAnalysis.Declarations.MergedDeclaration;
    using __Symbol = global::MetaDslx.CodeAnalysis.Symbols.Symbol;
    using __ErrorSymbolInfo = global::MetaDslx.CodeAnalysis.Symbols.ErrorSymbolInfo;
    using __ModelProperty = global::MetaDslx.CodeAnalysis.Symbols.ModelPropertyAttribute;
    using __CompletionGraph = global::MetaDslx.CodeAnalysis.Symbols.CompletionGraph;
    using __CompletionPart = global::MetaDslx.CodeAnalysis.Symbols.CompletionPart;
    using __DiagnosticBag = global::MetaDslx.CodeAnalysis.DiagnosticBag;
    using __SourceLocation = global::MetaDslx.CodeAnalysis.SourceLocation;
    using __CancellationToken = global::System.Threading.CancellationToken;
    using __NotImplementedException = global::System.NotImplementedException;
    using __ImmutableAttributeSymbols = global::System.Collections.Immutable.ImmutableArray<global::MetaDslx.CodeAnalysis.Symbols.AttributeSymbol>;

    public partial class [GetInstName(symbol, symbol)] : global::MetaDslx.CodeAnalysis.Symbols.SymbolInst, [GetIntfName(symbol, symbol)]
    {
        [foreach (var prop in GetProperties(symbol))]
            [if (prop.IsWeak)]
                private static [GetFieldType(symbol, prop)] [GetFieldName(prop)] = new [GetFieldType(symbol, prop)]();
            [else]
                private [GetFieldType(symbol, prop)] [GetFieldName(prop)];
            [end if]
        [end foreach]
        // TODO
    }
}
end template

template GenerateImplementation(Symbol symbol)
using System.Threading;
using System.Collections.Immutable;
using MetaDslx.Modeling;
using MetaDslx.CodeAnalysis;
using MetaDslx.CodeAnalysis.Declarations;
using MetaDslx.CodeAnalysis.Symbols;

namespace [symbol.NamespaceName].__Impl
{
    public class [GetImplName(symbol, symbol)] : [GetBaseName(symbol, symbol)]
    {
    }
}
end template

template AssignProperty(Symbol symbol, Property prop, string variable)
    [if (prop.IsWeak)]
        [if (prop.Type.Dimensions > 0)]
            if (![variable].IsDefaultOrEmpty)
            {
                [GetFieldName(prop)].Add(this, [variable]);
            }
        [else]
            if ([variable] != [GetDefaultValue(symbol, prop)])
            {
                [GetFieldName(prop)].Add(this, [variable]);
            }
        [end if]
    [else]
        [GetFieldName(prop)] = [variable];
    [end if]
end template

template CallImpl(Symbol symbol, string func)
    CallImpl<[GetIntfName(symbol, symbol)], [GetImplName(symbol, symbol)]>(impl => impl.[func])
end template

template CallImpl(Symbol symbol, string type, string func)
    CallImpl<[type], [GetIntfName(symbol, symbol)], [GetImplName(symbol, symbol)]>(impl => impl.[func])
end template

