namespace MetaDslx.Bootstrap.MetaModel.Generators;

using System;
using MetaDslx.Bootstrap.MetaModel.Core;

generator MetaModelGenerator;

template Generate()
namespace [Namespace]
{
	using __MetaModel = global::MetaDslx.Modeling.MetaModel;
	using __ModelVersion = global::MetaDslx.Modeling.ModelVersion;
	using __ModelObjectInfo = global::MetaDslx.Modeling.ModelObjectInfo;
	using __ModelProperty = global::MetaDslx.Modeling.ModelProperty;
    using __ModelPropertyFlags = global::MetaDslx.Modeling.ModelPropertyFlags;
	using __ImmutableArray = global::System.Collections.Immutable.ImmutableArray;
	using __ImmutableDictionary = global::System.Collections.Immutable.ImmutableDictionary;
	using __Type = global::System.Type;

	[GenerateMetaModel(MetaModel)]

	[foreach (var cls in Classes)]
	[GenerateInterface(MetaModel, cls)]

	[end foreach]
}

namespace [Namespace].__Impl
{
	using __Model = global::MetaDslx.Modeling.Model;
	using __MetaModel = global::MetaDslx.Modeling.MetaModel;
	using __IModelObject = global::MetaDslx.Modeling.IModelObject;
	using __MetaModelObject = global::MetaDslx.Modeling.MetaModelObject;
	using __ModelObjectInfo = global::MetaDslx.Modeling.ModelObjectInfo;
	using __ModelProperty = global::MetaDslx.Modeling.ModelProperty;
	using __ModelPropertyFlags = global::MetaDslx.Modeling.ModelPropertyFlags;
	using __ModelPropertyInfo = global::MetaDslx.Modeling.ModelPropertyInfo;
	using __ModelPropertySlot = global::MetaDslx.Modeling.ModelPropertySlot;
	using __ImmutableArray = global::System.Collections.Immutable.ImmutableArray;
	using __ImmutableDictionary = global::System.Collections.Immutable.ImmutableDictionary;
	using __Type = global::System.Type;

	[foreach (var cls in Classes)]
	[GenerateClass(MetaModel, cls)]

	[end foreach]
}
end template

template GenerateMetaModel(MetaModel mm)
public class [mm.Name] : __MetaModel
{
	private static readonly [mm.Name] _instance;
	public static [mm.Name] Instance => _instance;

	[foreach (var cls in mm.Parent.Declarations.OfType<MetaClass>())]
	[foreach (var prop in cls.Properties)]
	private static readonly __ModelProperty _[cls.Name]_[prop.Name];
	[end foreach]
	[end foreach]

	static [mm.Name]()
	{
		[foreach (var cls in Classes)]
			[var metaCls = Graph.GetMetaClass(cls)]
			[foreach (var prop in metaCls.DeclaredProperties)]
		_[cls.Name]_[prop.Name] = new __ModelProperty(typeof([cls.Name]), "[prop.Name]", typeof([ToCSharp(prop.Type)]), null, [ToCSharp(prop.Flags)], [if(prop.SymbolProperty is null)]null[else]"[prop.SymbolProperty]"[end if]);
			[end foreach]
		[end foreach]
		_instance = new [mm.Name]();
	}

	private readonly global::System.Collections.Immutable.ImmutableArray<__Type> _modelObjectTypes;
	private readonly global::System.Collections.Immutable.ImmutableArray<__ModelObjectInfo> _modelObjectInfos;
	private readonly global::System.Collections.Immutable.ImmutableDictionary<__Type, __ModelObjectInfo> _modelObjectInfosByType;
	private readonly global::System.Collections.Immutable.ImmutableDictionary<string, __ModelObjectInfo> _modelObjectInfosByName;

	private [mm.Name]()
	{
		_modelObjectTypes = __ImmutableArray.Create<__Type>([foreach (var cls in mm.Parent.Declarations.OfType<MetaClass>()) separator ", "]typeof([cls.Name])[end foreach]);
		_modelObjectInfos = __ImmutableArray.Create<__ModelObjectInfo>([foreach (var cls in mm.Parent.Declarations.OfType<MetaClass>()) separator ", "][cls.Name]Info[end foreach]);
		var modelObjectInfosByType = __ImmutableDictionary.CreateBuilder<__Type, __ModelObjectInfo>();
		[foreach (var cls in Classes)]
		modelObjectInfosByType.Add(typeof([cls.Name]), [cls.Name]Info);
		[end foreach]
		_modelObjectInfosByType = modelObjectInfosByType.ToImmutable();
		var modelObjectInfosByName = __ImmutableDictionary.CreateBuilder<string, __ModelObjectInfo>();
		[foreach (var cls in Classes)]
		modelObjectInfosByName.Add("[cls.Name]", [cls.Name]Info);
		[end foreach]
		_modelObjectInfosByName = modelObjectInfosByName.ToImmutable();
	}

    public override string Name => nameof([mm.Name]);
    public override string FullName => "[mm.FullName]";
    public override __ModelVersion Version => default;
    public override string Uri => "[mm.FullName]";
    public override string Prefix => "[string.Concat(mm.Name.Where(c => char.IsUpper(c)).Select(c => char.ToLower(c)))]";

	public override global::System.Collections.Immutable.ImmutableArray<__Type> ModelObjectTypes => _modelObjectTypes;
	public override global::System.Collections.Immutable.ImmutableArray<__ModelObjectInfo> ModelObjectInfos => _modelObjectInfos;

    public override bool Contains(__Type modelObjectType) => _modelObjectInfosByType.Keys.Contains(modelObjectType);
    public override bool Contains(string modelObjectTypeName) => _modelObjectInfosByName.Keys.Contains(modelObjectTypeName);

    public override bool TryGetInfo(__Type modelObjectType, out __ModelObjectInfo info) => _modelObjectInfosByType.TryGetValue(modelObjectType, out info);
    public override bool TryGetInfo(string modelObjectTypeName, out __ModelObjectInfo info) => _modelObjectInfosByName.TryGetValue(modelObjectTypeName, out info);

	[foreach (var cls in mm.Parent.Declarations.OfType<MetaClass>())]
	public static __ModelObjectInfo [cls.Name]Info => __Impl.[cls.Name]_Impl.__Info.Instance;
	[foreach (var prop in cls.Properties)]
	public static __ModelProperty [cls.Name]_[prop.Name] => _[cls.Name]_[prop.Name];
	[end foreach]
	[end foreach]
}
end template

template GenerateInterface(MetaModel mm, MetaClass cls)
public interface [cls.Name][if (cls.BaseTypes.Any())] : [foreach (var bt in cls.BaseTypes) separator ", "]global::[bt.FullName][end foreach][end if]
{

}
end template

template GenerateClass(MetaModel mm, MetaClass cls)
[var metaCls = Graph.GetMetaClass(cls)]
internal class [cls.Name]_Impl : __MetaModelObject, [cls.Name]
{
	private [cls.Name]_Impl(string? id)
		: base(id)
	{
	}

	protected override __ModelObjectInfo MInfo => __Info.Instance;

	internal class __Info : __ModelObjectInfo
	{
		public static readonly __Info Instance = new __Info();

		private readonly global::System.Collections.Immutable.ImmutableArray<__ModelProperty> _declaredProperties;
		private readonly global::System.Collections.Immutable.ImmutableArray<__ModelProperty> _allDeclaredProperties;
		private readonly global::System.Collections.Immutable.ImmutableArray<__ModelProperty> _publicProperties;
        private readonly global::System.Collections.Immutable.ImmutableDictionary<string, __ModelProperty> _publicPropertiesByName;
        private readonly global::System.Collections.Immutable.ImmutableDictionary<__ModelProperty, __ModelPropertyInfo> _modelPropertyInfos;

		private __Info() 
		{
			_declaredProperties = __ImmutableArray.Create<__ModelProperty>([foreach (var prop in metaCls.DeclaredProperties) separator ", "][ToCSharp(prop)][end foreach]);
			_allDeclaredProperties = __ImmutableArray.Create<__ModelProperty>([foreach (var prop in metaCls.AllDeclaredProperties) separator ", "][ToCSharp(prop)][end foreach]);
			_publicProperties = __ImmutableArray.Create<__ModelProperty>([foreach (var prop in metaCls.PublicProperties) separator ", "][ToCSharp(prop)][end foreach]);
			var publicPropertiesByName = __ImmutableDictionary.CreateBuilder<string, __ModelProperty>();
			[foreach (var prop in metaCls.PublicProperties)]
			publicPropertiesByName.Add("[prop.Name]", [ToCSharp(prop)]);
			[end foreach]
			_publicPropertiesByName = publicPropertiesByName.ToImmutable();
			var modelPropertyInfos = __ImmutableDictionary.CreateBuilder<__ModelProperty, __ModelPropertyInfo>();
			[foreach (var prop in metaCls.AllDeclaredProperties)]
			[var info = metaCls.ModelPropertyInfos[prop]]
			[var slot = info.Slot]
			modelPropertyInfos.Add([ToCSharp(prop)], new __ModelPropertyInfo(new __ModelPropertySlot([ToCSharp(slot.SlotProperty)], [ToCSharp(slot.SlotProperties)], null, [ToCSharp(slot.Flags)]), [ToCSharp(info.OppositeProperties)], [ToCSharp(info.SubsettedProperties)], [ToCSharp(info.SubsettingProperties)], [ToCSharp(info.RedefinedProperties)], [ToCSharp(info.RedefiningProperties)], [ToCSharp(info.HiddenProperties)], [ToCSharp(info.HidingProperties)]));
			[end foreach]
			_modelPropertyInfos = modelPropertyInfos.ToImmutable();
		}

        public override __MetaModel MetaModel => [mm.Name].Instance;
        public override global::System.Type MetaType => typeof([cls.Name]);

        public override __Type? SymbolType => [if (metaCls.SymbolType is null)]null[else]typeof([ToCSharp(metaCls.SymbolType)])[end if];
        public override __ModelProperty? NameProperty => [if (metaCls.NameProperty is null)]null[else][ToCSharp(metaCls.NameProperty)][end if];
        public override __ModelProperty? TypeProperty => [if (metaCls.TypeProperty is null)]null[else][ToCSharp(metaCls.TypeProperty)][end if];
        public override global::System.Collections.Immutable.ImmutableArray<__ModelProperty> DeclaredProperties => _declaredProperties;
        public override global::System.Collections.Immutable.ImmutableArray<__ModelProperty> AllDeclaredProperties => _allDeclaredProperties;
        public override global::System.Collections.Immutable.ImmutableArray<__ModelProperty> PublicProperties => _publicProperties;

        protected override global::System.Collections.Immutable.ImmutableDictionary<string, __ModelProperty> PublicPropertiesByName => _publicPropertiesByName;
        protected override global::System.Collections.Immutable.ImmutableDictionary<__ModelProperty, __ModelPropertyInfo> ModelPropertyInfos => _modelPropertyInfos;

		public override __IModelObject? Create(__Model? model = null, string? id = null)
		{
			var result = new [cls.Name]_Impl(id);
			if (model is not null) model.AddObject(result);
			return result;
		}

	}
}
end template
