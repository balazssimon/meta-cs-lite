namespace MetaDslx.Bootstrap.MetaModel.Compiler;

using System;
using MetaDslx.CodeAnalysis.Annotations;
using MetaDslx.CodeAnalysis.Binding;
using MetaDslx.CodeAnalysis.Syntax;
using MetaDslx.CodeAnalysis.Symbols;
using MetaDslx.Bootstrap.MetaModel.Core;

language MetaCore;

Main returns MetaNamespace:
	'namespace' name=[Name(qualifierProperty:Declarations)]Qualifier ';'
	Using*
	Declarations
	eof;

Using returns ImportSymbol: 'using' namespaces+=#NamespaceSymbol ';';

[Scope]
part Declarations: declarations+=MetaDeclaration*;

MetaModel: 'metamodel' name=Name ';';

MetaDeclaration: MetaModel | MetaEnumType | MetaClass;

MetaEnumType: 'enum' name=Name EnumBody;
[Scope]
part EnumBody: '{' EnumLiterals? '}';
part EnumLiterals : literals+=MetaEnumLiteral (',' literals+=MetaEnumLiteral)* ;
MetaEnumLiteral: name=Name;

MetaClass: isAbstract?='abstract'? 'class' name=ClassName BaseClasses? ClassBody;
[Name]
[Identifier]
part ClassName: TIdentifier? '$' symbolType=[Use(types: Symbol, suffixes: Symbol)]Identifier | TIdentifier;
part BaseClasses: (':' baseTypes+=#{MetaClass|QualifierList});
[Scope]
part ClassBody: '{' properties+=MetaProperty* '}';

MetaProperty: (isContainment?='contains' | isDerived?='derived')? type=TypeReference name=PropertyName (PropertyOpposite | PropertySubsets | PropertyRedefines)* ';';
[Name]
[Identifier]
part PropertyName: TIdentifier? '$' symbolProperty=[Value(string)]TIdentifier | TIdentifier;
part PropertyOpposite: 'opposite' oppositeProperties+=#MetaProperty (',' oppositeProperties+=#MetaProperty)*;
part PropertySubsets: 'subsets' subsettedProperties+=#MetaProperty (',' subsettedProperties+=#MetaProperty)*;
part PropertyRedefines: 'redefines' redefinedProperties+=#MetaProperty (',' redefinedProperties+=#MetaProperty)*;

TypeReference returns MetaType: MetaPrimitiveType | MetaArrayType | #MetaType;
MetaPrimitiveType
	: 'bool' => MetaModel.Bool
	| 'int' => MetaModel.Int
	| 'string' => MetaModel.String
	| 'type' => MetaModel.Type
	;
MetaArrayType: itemType=TypeReference '[' ']';

[Name]
part Name: Identifier;

[DefaultReference]
[Qualifier]
part Qualifier: Identifier ('.' Identifier)*;

part QualifierList: Qualifier (',' Qualifier)*;

[Identifier]
part Identifier: TIdentifier;

token TInteger[Number] returns int: '0'| '1'..'9' ('0'..'9')* ;

token TDecimal[Number] returns double: ('0'|'1'..'9' ('0'..'9')*) '.' ('0'..'9')+ ;

token TIdentifier[DefaultIdentifier]: ('_'|'a'..'z'|'A'..'Z')+('_'|'a'..'z'|'A'..'Z'|'0'..'9')*;

token TComma[DefaultSeparator]: ',' ;

token TString[String] returns string: '"' .*? '"';

token TWhitespace[DefaultWhitespace]: ('\t'|' ') +;

token TLineEnd[DefaultEndOfLine]: ('\r\n' | '\r' | '\n');

token TSingleLineComment[SingleLineComment]: '//' ~('\r' | '\n')*;

token TMultiLineComment[MultiLineComment]: '/*' .*? '*/';
