namespace MetaDslx.Examples.MetaModel;

using System;
using MetaDslx.CodeAnalysis.Annotations;
using MetaDslx.CodeAnalysis.Binding;
using MetaDslx.CodeAnalysis.Syntax;
using MetaDslx.CodeAnalysis.Symbols;
using MetaDslx.Examples.MetaModel.Model;
using MetaDslx.Examples.MetaModel;

language MetaModel;

Main returns MetaNamespace:
	'namespace' name=[Name(qualifierProperty:Declarations)]Qualifier ';'
	UsingDeclaration*
	Declarations
	eof;

UsingDeclaration returns ImportSymbol: 'using' (namespaces+=#NamespaceSymbol | aliases+=ImportSymbolAlias) ';';
ImportSymbolAlias returns AliasSymbol: name=Name '=' target=#DeclaredSymbol;

[Scope]
part Declarations: definedMetaModel+=MetaModel (declarations+=MetaDeclaration | Association)*;

MetaModel: attributes+=MetaAttribute* 'metamodel' name=Name ';';

MetaDeclaration: MetaEnum | MetaClass;

MetaAttribute: '[' type=#MetaNamedType ']';

MetaEnum: attributes+=MetaAttribute* 'enum' name=Name EnumBody;
[Scope]
part EnumBody: '{' EnumLiterals? '}';
part EnumLiterals : enumLiterals+=MetaEnumLiteral (',' enumLiterals+=MetaEnumLiteral)* ;
MetaEnumLiteral: attributes+=MetaAttribute* name=Name;

MetaClass: {MetaClass} attributes+=MetaAttribute* isAbstract?='abstract'? 'class' name=Name BaseClasses? ClassBody;
part BaseClasses: (':' baseClasses+=#{MetaClass|QualifierList});
[Scope]
part ClassBody: '{' properties+=MetaProperty* '}';

MetaProperty: attributes+=MetaAttribute* (isContainment?='containment' | kind=MetaPropertyKind?) type=TypeReference name=Name PropertyRedefinition? PropertySubsetting? ';';
MetaPropertyKind: 'derived' => Derived | 'readonly' => Readonly;
part PropertyRedefinition: 'redefines' redefinedProperties+=#{MetaProperty|QualifierList};
part PropertySubsetting: 'subsets' subsettedProperties+=#{MetaProperty|QualifierList};

part Association: MetaAttribute* 'association' #MetaProperty 'with' #MetaProperty ';';

TypeReference returns MetaType: MetaPrimitiveType | MetaCollectionType | MetaNullableType | #TypeSymbol;
MetaPrimitiveType
	: 'int' => Meta.Int
	| 'string' => Meta.String
	| 'bool' => Meta.Bool;

MetaCollectionType: kind=('list' => List | 'set' => Set) '<' innerType=TypeReference '>';
MetaNullableType: innerType=TypeReference '?';

/*
Expression
	: {ReferenceExpression} ref=#Variable
	| {BinaryExpression} left=Expression operator=('+'=>Add|'-'=>Subtract) right=Expression
	| {BinaryExpression} left=Expression operator=('*'=>Multiply|'/'=>Divide) right=Expression
	;
*/

[Name]
part Name: Identifier;

[DefaultReference]
[Qualifier]
part Qualifier: Identifier ('.' Identifier)*;

part QualifierList: Qualifier (',' Qualifier)*;

[Identifier]
part Identifier: TIdentifier;

token TInteger[Number] returns int: '0'| '1'..'9' ('0'..'9')* ;

token TDecimal[Number] returns double: ('0'|'1'..'9' ('0'..'9')*) '.' ('0'..'9')+ ;

token TIdentifier[DefaultIdentifier]: ('_'|'a'..'z'|'A'..'Z')+('_'|'a'..'z'|'A'..'Z'|'0'..'9')*;

token TComma[DefaultSeparator]: ',' ;

token TString[String]: '"' .*? '"';

token TWhitespace[DefaultWhitespace]: ('\t'|' ') +;

token TLineEnd[DefaultEndOfLine]: ('\r\n' | '\r' | '\n');

token TSingleLineComment[SingleLineComment]: '//' ~('\r' | '\n')*;

token TMultiLineComment[MultiLineComment]: '/*' .*? '*/';
