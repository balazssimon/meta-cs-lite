namespace MetaDslx.Examples.MetaModel;

using System;
using MetaDslx.CodeAnalysis.Annotations;
using MetaDslx.CodeAnalysis.Binding;
using MetaDslx.Examples.MetaModel.Model;
using MetaDslx.Examples.MetaModel;

language MetaModel;

Main returns MetaNamespace: declarations+=MetaNamespace eof;

MetaNamespace: 'namespace' [Nesting(MetaNamespace,Declarations)] qualifiedName ';' usingDeclarations [Scope] MetaNamespaceDeclarations;
part MetaNamespaceDclarations : declarations+=MetaModel declarations+=Declaration*;

usingDeclarations : usingDeclaration*;

[Import]
usingDeclaration : 'using' [Use(MetaNamespace)] qualifier ';';

MetaModel: attributes+=attribute* 'metamodel' name=name ';';

Declaration: MetaEnum | MetaClass | Association;

MetaAttribute: '[' type=[Use(MetaNamedType)]qualifier ']';

MetaEnum: attributes+=attribute* 'enum' name=name EnumBody;
[Scope]
part EnumBody: '{' enumLiterals+=EnumLiterals? '}';
part EnumLiterals : MetaEnumLiteral (',' MetaEnumLiteral)* ;
MetaEnumLiteral: attribute* name;

MetaClass: attributes+=attribute* isAbstract?='abstract'? 'class' name=name (':' baseClasses+=[Use(MetaClass)]qualifierList)? ClassBody;
[Scope]
part ClassBody : '{' properties+=propertyDeclaration* '}';

MetaProperty : attributes+=attribute* kind=propertyModifier? type=typeReference name=name propertyRedefinition? propertySubsetting? ';';
part propertyModifier : [Constant(MetaPropertyKind.Derived)] 'derived' | isContainment?='containment' | [Constant(MetaPropertyKind.Derived)] 'readonly';
part PropertyRedefinition : 'redefines' [Use(MetaProperty)] redefinedProperties+=qualifierList;
part PropertySubsetting : 'subsets' [Use(MetaProperty)]subsettedProperties+=qualifierList;

Association: attribute* 'association' [Use(MetaProperty)] qualifier 'with' [Use(MetaProperty)] qualifier ';';

typeReference : primitiveType | collectionType | nullableType | [Use(MetaType)] qualifier;

primitiveType 
	: [Constant(Meta.Int)] 'int' 
	| [Constant(Meta.String)] 'string' 
	| [Constant(Meta.Bool)] 'bool';

[Define(MetaCollectionType)]
collectionType : ([Property(Kind,MetaCollectionKind.List)] 'list' | [Property(Kind,MetaCollectionKind.Set)] 'set') '<' [Property(InnerType)] typeReference '>';
[Define(MetaNullableType)]
nullableType : [Property(InnerType)] typeReference '?';

[Name]
qualifiedName : qualifier;

qualifierList : qualifier (',' qualifier)*;

[Qualifier]
qualifier : identifier ('.' identifier)*;

[Name]
name : identifier;

[Identifier]
identifier : TIdentifier;

token TInteger as Number: '0'| '1'..'9' ('0'..'9')* ;
token TDecimal as Number: ('0'|'1'..'9' ('0'..'9')*) '.' ('0'..'9')+ ;
token TIdentifier as default Identifier: ('_'|'a'..'z'|'A'..'Z')+('_'|'a'..'z'|'A'..'Z'|'0'..'9')*;
token TComma as default Separator: ',' ;
token TString as String: '"' .*? '"';
token TWhitespace as default Whitespace: ('\t'|' ') +;
token TLineEnd as default EndOfLine: ('\r\n' | '\r' | '\n');
token TSingleLineComment as SingleLineComment: '//' ~('\r' | '\n')*;
token TMultiLineComment as MultiLineComment: '/*' .*? '*/';
