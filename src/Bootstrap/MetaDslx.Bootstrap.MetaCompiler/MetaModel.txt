namespace MetaDslx.Examples.MetaModel;

using System;
using MetaDslx.CodeAnalysis.Annotations;
using MetaDslx.CodeAnalysis.Binding;
using MetaDslx.CodeAnalysis.Syntax;
using MetaDslx.Examples.MetaModel.Model;
using MetaDslx.Examples.MetaModel;

language MetaModel;

Main returns MetaNamespace: declarations+=MetaNamespace eof;

MetaNamespace: 'namespace' [Nesting(MetaNamespace,Declarations)] QualifiedName ';' UsingDeclarations MetaNamespaceDeclarations;

[Scope]
part MetaNamespaceDeclarations: declarations+=MetaModel declarations+=MetaDeclaration*;

part UsingDeclarations: UsingDeclaration*;

[Import]
part UsingDeclaration: 'using' [Use(MetaNamespace)] Qualifier ';';

MetaModel: attributes+=MetaAttribute* 'metamodel' name=Name ';';

MetaDeclaration: MetaEnum | MetaClass | Association;

MetaAttribute: '[' type=[Use(MetaNamedType)]Qualifier ']';

MetaEnum: attributes+=MetaAttribute* 'enum' name=Name EnumBody;
[Scope]
part EnumBody: '{' EnumLiterals? '}';
part EnumLiterals : enumLiterals+=MetaEnumLiteral (',' enumLiterals+=MetaEnumLiteral)* ;
MetaEnumLiteral: attributes+=MetaAttribute* name=Name;

MetaClass: attributes+=MetaAttribute* isAbstract?='abstract'? 'class' name=Name (':' baseClasses+=[Use(MetaClass)]QualifierList)? ClassBody;
[Scope]
part ClassBody: '{' properties+=MetaProperty* '}';

MetaProperty: attributes+=MetaAttribute* kind=PropertyModifier? type=TypeReference name=Name PropertyRedefinition? PropertySubsetting? ';';
part PropertyModifier: [Constant(MetaPropertyKind.Derived)] 'derived' | isContainment?='containment' | [Constant(MetaPropertyKind.Derived)] 'readonly';
part PropertyRedefinition: 'redefines' [Use(MetaProperty)] redefinedProperties+=QualifierList;
part PropertySubsetting: 'subsets' [Use(MetaProperty)] subsettedProperties+=QualifierList;

Association: MetaAttribute* 'association' [Use(MetaProperty)] Qualifier 'with' [Use(MetaProperty)] Qualifier ';';

TypeReference returns MetaType: MetaPrimitiveType | MetaCollectionType | MetaNullableType | [Use(MetaType)] Qualifier;
MetaPrimitiveType
	: [Constant(Meta.Int)] 'int' 
	| [Constant(Meta.String)] 'string' 
	| [Constant(Meta.Bool)] 'bool';

MetaCollectionType: ([Property(Kind,MetaCollectionKind.List)] 'list' | [Property(Kind,MetaCollectionKind.Set)] 'set') '<' innerType=TypeReference '>';
MetaNullableType: innerType=TypeReference '?';

[Name]
part QualifiedName: Qualifier;

part QualifierList: Qualifier (',' Qualifier)*;

[Qualifier]
part Qualifier: Identifier ('.' Identifier)*;

[Name]
part Name: Identifier;

[Identifier]
part Identifier: TIdentifier;

token TInteger as Number returns int: '0'| '1'..'9' ('0'..'9')* ;
token TDecimal as Number returns double: ('0'|'1'..'9' ('0'..'9')*) '.' ('0'..'9')+ ;
token TIdentifier as default Identifier returns string: ('_'|'a'..'z'|'A'..'Z')+('_'|'a'..'z'|'A'..'Z'|'0'..'9')*;
token TComma as default Separator: ',' ;
token TString as String returns string: '"' .*? '"';
token TWhitespace as default Whitespace: ('\t'|' ') +;
token TLineEnd as default EndOfLine: ('\r\n' | '\r' | '\n');
token TSingleLineComment as SingleLineComment: '//' ~('\r' | '\n')*;
token TMultiLineComment as MultiLineComment: '/*' .*? '*/';
