namespace MetaDslx.Bootstrap.MetaCompiler.Generators

using MetaDslx.Bootstrap.MetaCompiler.Roslyn
using System.Collections.Generic
using System.Collections.Immutable
using System.Linq

generator RoslynApiGenerator


template GenerateSemanticsFactory(Language language)
using System;
using MetaDslx.CodeAnalysis;
using MetaDslx.CodeAnalysis.Declarations;
using MetaDslx.CodeAnalysis.Binding;

#nullable enable

namespace [language.Namespace]
{
    public class [language.Name]SemanticsFactory : SemanticsFactory
    {
        public [language.Name]SemanticsFactory(Compilation compilation, Language language) 
            : base(compilation, language)
        {
        }

        public override BinderFactoryVisitor CreateBinderFactoryVisitor(BinderFactory binderFactory)
        {
            return new global::[language.Namespace].Binding.[language.Name]BinderFactoryVisitor(binderFactory);
        }
    }
}
end template


template GenerateBinderFactoryVisitor(Language language)
using System;
using System.Collections.Immutable;
using MetaDslx.CodeAnalysis;

#nullable enable

namespace [language.Namespace].Binding
{
    using global::[language.Namespace].Syntax;

    public class [language.Name]BinderFactoryVisitor : MetaDslx.CodeAnalysis.Binding.BinderFactoryVisitor, I[language.Name]SyntaxVisitor
    {
        internal [language.Name]BinderFactoryVisitor(MetaDslx.CodeAnalysis.Binding.BinderFactory binderFactory)
            : base(binderFactory)
        {
        }

		[foreach (var rule in language.Rules)]
			[foreach (var alt in rule.Alternatives)]

        [GenerateBinderFactoryVisit(language, rule, alt)]
			[end foreach]
		[end foreach]

		public virtual void VisitSkippedTokensTrivia([language.Name]SkippedTokensTriviaSyntax node)
		{
		}
    }
}
end template

template GenerateBinderFactoryVisit(Language language, Rule rule, Alternative alt)
public virtual void Visit[alt.Name]([alt.RedName] node)
{
    [if (rule == language.MainRule)]
    if (this.IsRoot)
    {
        [if (language.RootTypeName is not null)]
        var __rootAnnot = new global::MetaDslx.CodeAnalysis.Binding.RootBinder(node.SyntaxTree, type: typeof([language.RootTypeName]));
        [else]
        var __rootAnnot = new global::MetaDslx.CodeAnalysis.Binding.RootBinder(node.SyntaxTree, type: null);
        [end if]
        this.Begin(__rootAnnot, node);
        try
        {
            [GenerateBinderFactoryVisitBody(language, rule, alt)]
        }
        finally
        {
            this.End(__rootAnnot);
        }
    }
    else
    {
    	[GenerateBinderFactoryVisitBody(language, rule, alt)]
    }
    [else]
	[GenerateBinderFactoryVisitBody(language, rule, alt)]
    [end if]
}
end template

template GenerateBinderFactoryVisitBody(Language language, Rule rule, Alternative alt)
[var annotIndex = 0]
[var body = GenerateBinderFactoryVisitElements(language, alt, ref annotIndex)]
[body = GenerateBinderFactoryVisitBinders(alt.Binders, "node", body, false, ref annotIndex)]
[body = GenerateBinderFactoryVisitBinders(rule.Binders, "node", body, false, ref annotIndex)]
[body]
end template

template GenerateBinderFactoryVisitElements(Language language, Alternative alt, ref int annotIndex)
[foreach (var elem in alt.Elements.Where(e => e.ContainsBinders))]
[GenerateBinderFactoryVisitElement(language, alt, elem, ref annotIndex)]
[end foreach]    
end template

template GenerateBinderFactoryVisitBinders(IEnumerable<Binder> binders, string nodeName, string body, bool negated, ref int annotIndex)
[foreach (var binder in binders.Where(b => b.IsNegated == negated).Reverse())]
[body = GenerateBinderFactoryVisitBinder(binder, nodeName, body, ref annotIndex)]
[end foreach]
[body]
end template

template GenerateBinderFactoryVisitBinder(Binder binder, string nodeName, string body, ref int annotIndex)
[var binderVarName = "__annot"+(annotIndex++)]
var [binderVarName] = new [binder.TypeName]([binder.ConstructorArguments]);
this.Begin([binderVarName], [nodeName]);
try
{
    [body]
}
finally
{
    this.End([binderVarName]);
}
end template

template GenerateBinderFactoryVisitElement(Language language, Alternative alt, Element elem, ref int annotIndex)
    [var isList = MetaDslx.Bootstrap.MetaCompiler.Model.MultiplicityExtensions.IsList(elem.Multiplicity)]
    [if (isList)]
[GenerateBinderFactoryVisitListElement(language, alt, elem, ref annotIndex)]
    [else if (elem.Value is SeparatedList sl)]
[GenerateBinderFactoryVisitSeparatedListElement(language, alt, elem, sl, ref annotIndex)]
    [else]
[GenerateBinderFactoryVisitElementValue(language, "node."+elem.PropertyName, elem, elem.Value, ref annotIndex)]
    [end if]
end template

template GenerateBinderFactoryVisitListElement(Language language, Alternative alt, Element elem, ref int annotIndex)
var [elem.ParameterName]List = node.[elem.PropertyName];
[var indexName = elem.ParameterName+"Index"]
for (var [indexName] = 0; [indexName] < [elem.ParameterName]List.Count; ++[indexName])
{
    [var elemName = "node."+elem.PropertyName+"["+indexName+"]"]
    [GenerateBinderFactoryVisitElementValue(language, elemName, elem, elem.Value, ref annotIndex)]
}
end template

template GenerateBinderFactoryVisitSeparatedListElement(Language language, Alternative alt, Element elem, SeparatedList list, ref int annotIndex)
var [elem.ParameterName]List = node.[elem.PropertyName];
[var indexName = elem.ParameterName+"Index"]
for (var [indexName] = 0; [indexName] < [elem.ParameterName]List.Count; ++[indexName])
{
    bool __itemHandled = false;
    bool __sepHandled = false;
    [var itemName = "node."+elem.PropertyName+"["+indexName+"]"]
    [var sepName = "node."+elem.PropertyName+".GetSeparator("+indexName+")"]
    [var firstCount = Math.Max(list.FirstItems.Count, list.FirstSeparators.Count)]
    [var lastCount = Math.Min(list.LastItems.Count, list.LastSeparators.Count)]
    [var ifElse = ""]
    [for (int i = 0; i < firstCount - 1; ++i)]
    [ifElse]if ([indexName] == [i])
    {
        [GenerateBinderFactoryVisitSeparatedListItem(language, itemName, list.FirstItems[i], sepName, list.FirstSeparators[i], list.SeparatorFirst, ref annotIndex)]
        __itemHandled = true;
        __sepHandled = true;
    }
        [ifElse = "else"]
    [end for]
    [if (firstCount > 0)]
    [ifElse]if ([indexName] == [firstCount-1])
    {
        [if (list.SeparatorFirst)]
        [GenerateBinderFactoryVisitElementValue(language, sepName, list.FirstSeparators[firstCount-1], list.FirstSeparators[firstCount-1].Value, ref annotIndex)]
        __sepHandled = true;
        [else]
        [GenerateBinderFactoryVisitElementValue(language, itemName, list.FirstItems[firstCount-1], list.FirstItems[firstCount-1].Value, ref annotIndex)]
        __itemHandled = true;
        [end if]
    }
        [ifElse = "else"]
    [end if]
    [for (int i = 0; i < lastCount; ++i)]
    [ifElse]if ([indexName] == [elem.ParameterName]List.Count - [lastCount - i])
    {
        [var j = lastCount - 1 - i]
        [if (j < list.LastItems.Count && j < list.LastSeparators.Count)]
        [GenerateBinderFactoryVisitSeparatedListItem(language, itemName, list.LastItems[j], sepName, list.LastSeparators[j], list.RepeatedSeparatorFirst, ref annotIndex)]
        __itemHandled = true;
        __sepHandled = true;
        [else if (j < list.LastItems.Count)]
        [GenerateBinderFactoryVisitElementValue(language, itemName, list.LastItems[j], list.LastItems[j].Value, ref annotIndex)]
        __itemHandled = true;
        [else if (j < list.LastSeparators.Count)]
        [GenerateBinderFactoryVisitElementValue(language, sepName, list.LastSeparators[j], list.LastSeparators[j].Value, ref annotIndex)]
        __sepHandled = true;
        [else]
        INTERNAL ERROR
        [end if]
    }
        [ifElse = "else"]
    [end for]
    if (!__itemHandled && [indexName] < node.[elem.PropertyName].Count)
    {
        [var repItemBody = GenerateBinderFactoryVisitElementValue(language, itemName, list.RepeatedItem, list.RepeatedItem.Value, ref annotIndex)]
        [GenerateBinderFactoryVisitBinders(list.RepeatedBlock.Binders, itemName, repItemBody, false, ref annotIndex)]
    }
    if (!__sepHandled && [indexName] < node.[elem.PropertyName].SeparatorCount)
    {
        [var repSepBody = GenerateBinderFactoryVisitElementValue(language, sepName, list.RepeatedSeparator, list.RepeatedSeparator.Value, ref annotIndex)]
        [GenerateBinderFactoryVisitBinders(list.RepeatedBlock.Binders, itemName, repSepBody, false, ref annotIndex)]
    }
}
end template

template GenerateBinderFactoryVisitSeparatedListItem(Language language, string itemName, Element itemElem, string sepName, Element sepElem, bool separatorFirst, ref int annotIndex)
[if (separatorFirst)]
[GenerateBinderFactoryVisitElementValue(language, sepName, sepElem, sepElem.Value, ref annotIndex)]
[GenerateBinderFactoryVisitElementValue(language, itemName, itemElem, itemElem.Value, ref annotIndex)]
[else]
[GenerateBinderFactoryVisitElementValue(language, itemName, itemElem, itemElem.Value, ref annotIndex)]
[GenerateBinderFactoryVisitElementValue(language, sepName, sepElem, sepElem.Value, ref annotIndex)]
[end if]
end template

template GenerateBinderFactoryVisitElementValue(Language language, string elemName, Element elem, ElementValue elemValue, ref int annotIndex)
    [if (elemValue is TokenAlts alts)]
switch ([elemName].Get[language.Name]Kind())
{
        [foreach (var alt in alts.Tokens)]
    case [language.Name]SyntaxKind.[alt.Token.Name]:
        [var altBody = GenerateBinderFactoryVisitElementValue(language, elemName, elem, alt, ref annotIndex)]
        [altBody = GenerateBinderFactoryVisitBinders(elemValue.Binders, elemName, altBody, false, ref annotIndex)]
        [GenerateBinderFactoryVisitBinders(elem.Binders, elemName, altBody, false, ref annotIndex)]
        break;
        [end foreach]
    default:
        [var defaultBody = GenerateBinderFactoryVisitBinders(elemValue.Binders, elemName, "// default", true, ref annotIndex)]
        [GenerateBinderFactoryVisitBinders(elem.Binders, elemName, defaultBody, true, ref annotIndex)]
        break;
}
    [else]
        [var elemBody = GenerateBinderFactoryVisitElementBody(elemName, elemValue)]
[elemBody = GenerateBinderFactoryVisitBinders(elemValue.Binders, elemName, elemBody, false, ref annotIndex)]
[GenerateBinderFactoryVisitBinders(elem.Binders, elemName, elemBody, false, ref annotIndex)]
    [end if]
end template

template GenerateBinderFactoryVisitElementBody(string elemName, ElementValue elemValue)
    [if (elemValue is TokenRef)]
//this.VisitToken([elemName]);
    [else]
this.Visit([elemName]);
    [end if]
end template

