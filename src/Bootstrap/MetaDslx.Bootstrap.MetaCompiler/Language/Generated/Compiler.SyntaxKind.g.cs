
#nullable enable

namespace MetaDslx.Bootstrap.MetaCompiler.Compiler.Syntax
{
    using __SyntaxToken = global::MetaDslx.CodeAnalysis.SyntaxToken;
    using __InternalSyntaxKind = global::MetaDslx.CodeAnalysis.Syntax.InternalSyntax.InternalSyntaxKind;

	public enum CompilerSyntaxKind
	{
		__FirstToken = TComma,
		__LastToken = TInvalidToken,
		__FirstFixedToken = TComma,
		__LastFixedToken = KFalse,
		__FirstRule = Main,
		__LastRule = LexerAnnotationBlock1ArgumentsBlock,

		// Built-in:
		None = __InternalSyntaxKind.None,
		List = __InternalSyntaxKind.List,
		BadToken = __InternalSyntaxKind.BadToken,
		MissingToken = __InternalSyntaxKind.MissingToken,
		SkippedTokensTrivia = __InternalSyntaxKind.SkippedTokensTrivia,
		DisabledTextTrivia = __InternalSyntaxKind.DisabledTextTrivia,
		ConflictMarkerTrivia = __InternalSyntaxKind.ConflictMarkerTrivia,
		Eof = __InternalSyntaxKind.Eof,

		// Tokens:
		TComma,
		TUtf8Bom,
		KNamespace,
		TSemicolon,
		KUsing,
		KLanguage,
		TColon,
		TLParen,
		TRParen,
		THash,
		THashLBrace,
		TRBrace,
		KEof,
		KFragment,
		TTilde,
		TDot,
		TDotDot,
		TLBrace,
		TLBracket,
		TRBracket,
		TEq,
		TQuestionEq,
		TExclEq,
		TPlusEq,
		TQuestion,
		TAsterisk,
		TPlus,
		TQuestionQuestion,
		TAsteriskQuestion,
		TPlusQuestion,
		KBool,
		KInt,
		KDouble,
		KString,
		KType,
		KSymbol,
		KObject,
		KVoid,
		KReturns,
		TBar,
		KAlt,
		TEqGt,
		KToken,
		KHidden,
		KNull,
		KTrue,
		KFalse,
		TInteger,
		TDecimal,
		TIdentifier,
		TVerbatimIdentifier,
		TString,
		TWhitespace,
		TLineEnd,
		TSingleLineComment,
		TMultiLineComment,
		TInvalidToken,

		// Rules:
		Main,
		Using,
		LanguageDeclaration,
		Grammar,
		Rule,
		Token,
		Fragment,
		Alternative,
		Element,
		ElementValue,
		BlockAlternative,
		LAlternative,
		LElement,
		LElementValueTokens,
		LBlock,
		LRange,
		LReference,
		ExpressionAlt1,
		ArrayExpression,
		SingleExpression,
		ParserAnnotation,
		LexerAnnotation,
		AnnotationArgument,
		TypeReferenceIdentifierAlt1,
		TypeReferenceIdentifierAlt2,
		TypeReferenceAlt1,
		TypeReferenceAlt2,
		Name,
		Identifier,
		MainBlock1,
		RuleBlock1Alt1,
		RuleBlock1Alt2,
		RuleAlternativesBlock,
		AlternativeBlock1,
		AlternativeBlock2,
		ElementBlock1,
		Tokens,
		Block,
		RuleRefAlt1,
		RuleRefAlt2,
		RuleRefAlt3,
		BlockAlternativesBlock,
		BlockAlternativeBlock1,
		RuleRefAlt3ReferencedTypesBlock,
		RuleRefAlt3Block1,
		TokenBlock1Alt1,
		TokenBlock1Alt2,
		TokenAlternativesBlock,
		FragmentAlternativesBlock,
		LBlockAlternativesBlock,
		Tokens1,
		SingleExpressionBlock1Alt2,
		SingleExpressionBlock1Alt3,
		ParserAnnotationBlock1,
		LexerAnnotationBlock1,
		AnnotationArgumentBlock1,
		MainQualifierBlock,
		AlternativeBlock1Block1,
		TokenBlock1Alt1Block1,
		ArrayExpressionItemsBlock,
		ParserAnnotationBlock1ArgumentsBlock,
		LexerAnnotationBlock1ArgumentsBlock,
}

    public static class CompilerSyntaxKindExtensions
    {
        public static CompilerSyntaxKind GetCompilerKind(this __SyntaxToken token)
        {
            return (CompilerSyntaxKind)token.RawKind;
        }
    }
}
