namespace MetaDslx.Bootstrap.MetaCompiler.Compiler;

using System;
using MetaDslx.CodeAnalysis.Annotations;
using MetaDslx.CodeAnalysis.Binding;
using MetaDslx.CodeAnalysis.Syntax;
using MetaDslx.CodeAnalysis;
using MetaDslx.CodeAnalysis.Symbols;
using MetaDslx.Modeling;
using MetaDslx.Bootstrap.MetaCompiler.Model;
using MetaDslx.Bootstrap.MetaCompiler.Symbols;
//using metamodel MetaDslx.Bootstrap.MetaCompiler.Model.Compiler;

language Compiler;

Main returns Namespace:
	'namespace' name=[Name(qualifierProperty:Declarations)]Qualifier ';'
	Using*
	Declarations
	eof;

Using returns ImportSymbol
	: /*{ImportMetaModelSymbol} 'using' 'metamodel' symbols+=#DeclaredSymbol ';'
	| {ImportSymbolModelSymbol} 'using' 'symbols' namespaces+=#NamespaceSymbol ';'
	|*/ 'using' namespaces+=#NamespaceSymbol ';'
	;

[Scope]
part Declarations: declarations+=LanguageDeclaration declarations+=Rule*;

LanguageDeclaration returns MetaDslx.Bootstrap.MetaCompiler.Model.Language: 'language' name=Name ';' grammar=Grammar;

Grammar: [Scope](grammarRules+=GrammarRule*);

GrammarRule: Rule | Block | LexerRule;

Rule: annotations+=ParserAnnotation* [Name](returnType=ReturnTypeIdentifier | Identifier 'returns' returnType=ReturnTypeQualifier) ':' alternatives+=Alternative ('|' alternatives+=Alternative)* ';';
Block: annotations+=ParserAnnotation* 'block' name=Name ('returns' returnType=ReturnTypeQualifier)? ':' alternatives+=Alternative ('|' alternatives+=Alternative)* ';';
BlockInline returns Block: '(' alternatives+=Alternative ('|' alternatives+=Alternative)* ')';

Alternative: (annotations+=ParserAnnotation* 'alt' name=Name ('returns' returnType=ReturnTypeQualifier)? ':')? elements+=Element+ ('=>' returnValue=Expression)?;
Element: (nameAnnotations+=ParserAnnotation* symbolProperty+=[SymbolProperty]Identifier assignment=Assignment)? valueAnnotations+=ParserAnnotation* value=ElementValue multiplicity=Multiplicity?;
ElementValue: BlockInline | Eof1 | Keyword | RuleRef;
RuleRef: grammarRule=[Use(GrammarRule)]Identifier | '#' referencedTypes+=ReturnTypeQualifier | '#{' referencedTypes+=ReturnTypeQualifier (',' referencedTypes+=ReturnTypeQualifier)* '}' ;
Eof1 returns Eof: 'eof';
Keyword: text=TString;

LexerRule: Token | Fragment;
Token: annotations+=LexerAnnotation* ('token' name=Name ('returns' returnType=ReturnTypeQualifier)? | isTrivia?='hidden' name=Name) ':' alternatives+=LAlternative ('|' alternatives+=LAlternative)* ';';
Fragment: 'fragment' name=Name ':' alternatives+=LAlternative ('|' alternatives+=LAlternative)* ';';
LAlternative: elements+=LElement*;
LElement: isNegated?='~'? value=LElementValue multiplicity=Multiplicity?;
LElementValue: LBlock | LFixed | LWildCard | LRange | LReference /*| LSet*/;
LReference: rule=[Use(LexerRule)]Identifier;
LFixed: text=TString;
LWildCard: '.';
LRange: StartChar=TString '..' EndChar=TString;
// TODO: add sets if lexer modes are available
//LSet: '[' items+=LSetItem* ']';
//LSetItem: LSetChar | LSetRange;
//LSetChar: 
//LSetRange:
LBlock: '(' alternatives+=LAlternative ('|' alternatives+=LAlternative)* ')';

Expression: SingleExpression | ArrayExpression;
SingleExpression returns Expression: value=[ExpressionValue]('null' | 'true' | 'false' | TInteger | TString | SimpleQualifier);
ArrayExpression: '{' (items+=SingleExpression (',' items+=SingleExpression)*)? '}';

ParserAnnotation returns MetaDslx.Bootstrap.MetaCompiler.Model.Annotation: '[' attributeClass=[Use(types:{MetaDslx.CodeAnalysis.Binding.Binder,MetaDslx.CodeAnalysis.Annotations.Annotation},suffixes:{Binder,Annotation})]Qualifier AnnotationArguments? ']';
LexerAnnotation returns MetaDslx.Bootstrap.MetaCompiler.Model.Annotation: '[' attributeClass=[Use(types:{MetaDslx.CodeAnalysis.Syntax.TokenKind,MetaDslx.CodeAnalysis.Annotations.Annotation},suffixes:{TokenKind,Annotation})]Qualifier AnnotationArguments? ']';
part AnnotationArguments: '(' arguments+=AnnotationArgument (',' arguments+=AnnotationArgument)* ')';
AnnotationArgument: (namedParameter=[AnnotationArgument]Identifier ':')? value=Expression;

Assignment
	: '=' => Assign
	| '?=' => QuestionAssign
	| '!=' => NegatedAssign
	| '+=' => PlusAssign
	;

Multiplicity
	: '?' => ZeroOrOne
	| '*' => ZeroOrMore
	| '+' => OneOrMore
	| '??' => NonGreedyZeroOrOne
	| '*?' => NonGreedyZeroOrMore
	| '+?' => NonGreedyOneOrMore
	;

[Use(MetaType)]
part ReturnTypeIdentifier: TPrimitiveType | Identifier;

[Use(MetaType)]
part ReturnTypeQualifier: TPrimitiveType | Qualifier;

[Name]
part Name: Identifier;

[DefaultReference]
[Qualifier]
part Qualifier: Identifier ('.' Identifier)*;

part QualifierList: Qualifier (',' Qualifier)*;

[Identifier]
part Identifier: TIdentifier | TVerbatimIdentifier;

part SimpleQualifier: SimpleIdentifier ('.' SimpleIdentifier)*;
part SimpleIdentifier: TIdentifier;

token TInteger[Number] returns int: '0'| '1'..'9' ('0'..'9')* ;

token TDecimal[Number] returns double: ('0'|'1'..'9' ('0'..'9')*) '.' ('0'..'9')+ ;

token TPrimitiveType returns MetaType
	: 'bool'
	| 'int'
	| 'string'
	| 'type'
	| 'symbol'
	| 'object'
	| 'void'
	;

token TIdentifier[DefaultIdentifier]: ('_'|'a'..'z'|'A'..'Z')+('_'|'a'..'z'|'A'..'Z'|'0'..'9')*;
token TVerbatimIdentifier[Identifier]: '@'('_'|'a'..'z'|'A'..'Z')+('_'|'a'..'z'|'A'..'Z'|'0'..'9')*;

token TComma[DefaultSeparator]: ',' ;

token TString[String] returns string
    : '"' DoubleQuoteTextCharacter* '"'
    | '\'' SingleQuoteTextCharacter* '\'';

fragment DoubleQuoteTextCharacter : DoubleQuoteTextSimple | CharacterEscapeSimple | CharacterEscapeUnicode;
fragment DoubleQuoteTextSimple : ~('"' | '\\' | '\u000A' | '\u000D' | '\u0085' | '\u2028' | '\u2029');
fragment SingleQuoteTextCharacter : SingleQuoteTextSimple | CharacterEscapeSimple | CharacterEscapeUnicode;
fragment SingleQuoteTextSimple : ~('\'' | '\\' | '\u000A' | '\u000D' | '\u0085' | '\u2028' | '\u2029');
fragment CharacterEscapeSimple : '\\' CharacterEscapeSimpleCharacter;
fragment CharacterEscapeSimpleCharacter : '\'' | '"' | '\\' | '0' | 'a' | 'b' | 'f' | 'n' | 'r' | 't' | 'v'; 
fragment CharacterEscapeUnicode
    : '\\u' HexDigit HexDigit HexDigit HexDigit
    | '\\U' HexDigit HexDigit HexDigit HexDigit HexDigit HexDigit HexDigit HexDigit;
fragment HexDigit : ('0'..'9' | 'a'..'f' | 'A'..'F');

token Utf8Bom[Whitespace]: '\u00EF' '\u00BB' '\u00BF';

token TWhitespace[DefaultWhitespace]: ('\t'|' ') +;

token TLineEnd[DefaultEndOfLine]: ('\r\n' | '\r' | '\n');

token TSingleLineComment[SingleLineComment]: '//' ~('\r' | '\n')*;

token TMultiLineComment[MultiLineComment]: '/*' .*? '*/';

token TInvalidToken: .;
