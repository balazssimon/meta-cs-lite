namespace MetaDslx.Bootstrap.MetaCompiler.Compiler;

using System;
using MetaDslx.CodeAnalysis.Annotations;
using MetaDslx.CodeAnalysis.Binding;
using MetaDslx.CodeAnalysis.Syntax;
using MetaDslx.CodeAnalysis;
using MetaDslx.CodeAnalysis.Symbols;
using MetaDslx.Modeling;
using MetaDslx.Bootstrap.MetaCompiler.Model;
//using metamodel MetaDslx.Bootstrap.MetaCompiler.Model.Compiler;

language Compiler;

Main returns Namespace:
	'namespace' [Name(qualifierProperty:Declarations)]Qualifier ';'
	Using*
	Declarations
	eof;

Using returns ImportSymbol: 'using' (namespaces+=#NamespaceSymbol | 'metamodel' metaModels+=#MetaModel) ';';

part Declarations: declarations+=LanguageDeclaration declarations+=Rule*;

LanguageDeclaration returns MetaDslx.Bootstrap.MetaCompiler.Model.Language: 'language' Name ';';

Rule: ParserRule | BlockRule;// | TokenRule | FragmentRule;

ParserRule: Name ('returns' returnType=#MetaType)? ':' alternatives+=ParserRuleAlternative ('|' alternatives+=ParserRuleAlternative)* ';';
BlockRule returns ParserRule: isBlock?='block' Name ':' alternatives+=ParserRuleAlternative ('|' alternatives+=ParserRuleAlternative)* ';';
ParserRuleAlternative: ('{' returnType=#MetaType '}')? elements+=ParserRuleElement* ('=>' returnValue=Expression);
ParserRuleElement: Name;

Expression: NullExpression | BoolExpression | IntExpression | StringExpression | ReferenceExpression;
NullExpression: 'null';
BoolExpression: boolValue?='true' | 'false';
IntExpression: intValue=TInteger;
StringExpression: stringValue=TString;
ReferenceExpression: #MetaSymbol;

[Name]
part Name: Identifier;

[DefaultReference]
[Qualifier]
part Qualifier: Identifier ('.' Identifier)*;

part QualifierList: Qualifier (',' Qualifier)*;

[Identifier]
part Identifier: TIdentifier;

token TInteger[Number] returns int: '0'| '1'..'9' ('0'..'9')* ;

token TDecimal[Number] returns double: ('0'|'1'..'9' ('0'..'9')*) '.' ('0'..'9')+ ;

token TIdentifier[DefaultIdentifier]: ('_'|'a'..'z'|'A'..'Z')+('_'|'a'..'z'|'A'..'Z'|'0'..'9')*;

token TComma[DefaultSeparator]: ',' ;

token TString[String] returns string: '"' .*? '"';

token TWhitespace[DefaultWhitespace]: ('\t'|' ') +;

token TLineEnd[DefaultEndOfLine]: ('\r\n' | '\r' | '\n');

token TSingleLineComment[SingleLineComment]: '//' ~('\r' | '\n')*;

token TMultiLineComment[MultiLineComment]: '/*' .*? '*/';

token TInvalidToken: .;
