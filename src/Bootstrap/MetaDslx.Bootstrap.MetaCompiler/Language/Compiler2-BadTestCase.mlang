namespace MetaDslx.Bootstrap.MetaCompiler.Compiler;

using System;
using MetaDslx.CodeAnalysis.Annotations;
using MetaDslx.CodeAnalysis.Binding;
using MetaDslx.CodeAnalysis.Syntax;
using MetaDslx.CodeAnalysis;
using MetaDslx.CodeAnalysis.Symbols;
using MetaDslx.Modeling;
using metamodel MetaDslx.Bootstrap.MetaCompiler.Model.Compiler;

language Compiler;

Main returns Namespace:
	'namespace' [Name(qualifierProperty:Declarations)]Qualifier ';'
	Using*
	Declarations
	eof;

Using returns ImportSymbol: 'using' (namespaces+=#NamespaceSymbol | 'metamodel' metaModels+=#MetaModel) ';';

block Declarations: declarations+=LanguageDeclaration declarations+=Rule*;

LanguageDeclaration returns MetaDslx.Bootstrap.MetaCompiler.Model.Language: 'language' Name ';';

Rule: ParserRule | LexerRule;

ParserRule: annotations+=Annotation* (isBlock?='block' Name | Name ('returns' returnType=#MetaType)?) ':' alternatives+=PAlternative ('|' alternatives+=PAlternative)* ';';
PAlternative: ('{' returnType=#MetaType '}')? elements+=PElement* ('=>' returnValue=Expression)?;
PElement: (nameAnnotations+=Annotation* Name assignment=Assignment)? valueAnnotations+=Annotation* value=PElementValue multiplicity=Multiplicity?;
PElementValue: PReference | PEof | PKeyword | PBlock;
PReference: rule=[Use(Rule)]Identifier | '#' referencedTypes+=#MetaType | '#{' referencedTypes+=#MetaType (',' referencedTypes+=#MetaType)* '}' ;
PEof: 'eof';
PKeyword: text=TString;
PBlock: '(' alternatives+=PAlternative ('|' alternatives+=PAlternative)* ')';

LexerRule: annotations+=Annotation* ('token' Name ('returns' returnType=#MetaType)? | isHidden?='hidden' Name | isFragment?='fragment' Name) ':' alternatives+=LAlternative ('|' alternatives+=LAlternative)* ';';
LAlternative: elements+=LElement*;
LElement: isNegated?='~'? value=LElementValue multiplicity=Multiplicity?;
LElementValue: LReference | LFixed | LWildCard | LRange /*| LSet*/ | LBlock;
LReference: rule=[Use(LexerRule)]Identifier;
LFixed: text=TString;
LWildCard: '.';
LRange: StartChar=TString '..' EndChar=TString;
// TODO: add sets if lexer modes are available
//LSet: '[' items+=LSetItem* ']';
//LSetItem: LSetChar | LSetRange;
//LSetChar: 
//LSetRange:
LBlock: '(' alternatives+=LAlternative ('|' alternatives+=LAlternative)* ')';

Expression: NullExpression | BoolExpression | IntExpression | StringExpression | ReferenceExpression;
NullExpression: 'null';
BoolExpression: boolValue?='true' | 'false';
IntExpression: intValue=TInteger;
StringExpression: stringValue=TString;
ReferenceExpression: #MetaSymbol;

Annotation returns MetaDslx.Bootstrap.MetaCompiler.Model.Annotation: '[' type=Qualifier AnnotationArguments? ']';
block AnnotationArguments: '(' arguments+=AnnotationArgument (',' arguments+=AnnotationArgument)* ')';
AnnotationArgument: (name=Identifier ':')? value=Expression;

Assignment
	: '=' => Assign
	| '?=' => QuestionAssign
	| '!=' => NegatedAssign
	| '+=' => PlusAssign
	;

Multiplicity
	: '?' => ZeroOrOne
	| '*' => ZeroOrMore
	| '+' => OneOrMore
	| '??' => NonGreedyZeroOrOne
	| '*?' => NonGreedyZeroOrMore
	| '+?' => NonGreedyOneOrMore
	;


[Name]
block Name: Identifier;

[DefaultReference]
[Qualifier]
block Qualifier: Identifier ('.' Identifier)*;

block QualifierList: Qualifier (',' Qualifier)*;

[Identifier]
block Identifier: TIdentifier;

[Number]
token TInteger returns int: '0'| '1'..'9' ('0'..'9')* ;

[Number]
token TDecimal returns double: ('0'|'1'..'9' ('0'..'9')*) '.' ('0'..'9')+ ;

[DefaultIdentifier]
token TIdentifier: ('_'|'a'..'z'|'A'..'Z')+('_'|'a'..'z'|'A'..'Z'|'0'..'9')*;

[DefaultSeparator]
token TComma: ',' ;

[String]
token TString returns string
    : '"' DoubleQuoteTextCharacter* '"'
    | '\'' SingleQuoteTextCharacter* '\'';

fragment DoubleQuoteTextCharacter : DoubleQuoteTextSimple | CharacterEscapeSimple | CharacterEscapeUnicode;
fragment DoubleQuoteTextSimple : ~('"' | '\\' | '\u000A' | '\u000D' | '\u0085' | '\u2028' | '\u2029');
fragment SingleQuoteTextCharacter : SingleQuoteTextSimple | CharacterEscapeSimple | CharacterEscapeUnicode;
fragment SingleQuoteTextSimple : ~('\'' | '\\' | '\u000A' | '\u000D' | '\u0085' | '\u2028' | '\u2029');
fragment CharacterEscapeSimple : '\\' CharacterEscapeSimpleCharacter;
fragment CharacterEscapeSimpleCharacter : '\'' | '"' | '\\' | '0' | 'a' | 'b' | 'f' | 'n' | 'r' | 't' | 'v'; 
fragment CharacterEscapeUnicode
    : '\\u' HexDigit HexDigit HexDigit HexDigit
    | '\\U' HexDigit HexDigit HexDigit HexDigit HexDigit HexDigit HexDigit HexDigit;
fragment HexDigit : ('0'..'9' | 'a'..'f' | 'A'..'F');

[Whitespace]
token Utf8Bom: '\u00EF' '\u00BB' '\u00BF';

[DefaultWhitespace]
token TWhitespace: ('\t'|' ') +;

[DefaultEndOfLine]
token TLineEnd: ('\r\n' | '\r' | '\n');

[SingleLineComment]
token TSingleLineComment: '//' ~('\r' | '\n')*;

[MultiLineComment]
token TMultiLineComment: '/*' .*? '*/';

token TInvalidToken: .;
