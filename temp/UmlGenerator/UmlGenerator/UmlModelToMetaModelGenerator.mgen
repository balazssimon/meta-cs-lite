namespace UmlGenerator;
generator UmlModelToMetaModelGenerator for IEnumerable<ImmutableObject>;

using MetaDslx.Modeling;
using MetaDslx.Languages.Uml.Model;
using System.Collections.Immutable;
using Roslyn.Utilities;

properties Properties
	string Namespace = "";
	string ModelName = "";
end properties

extern function bool IsCollection(MultiplicityElement me)

extern function List<Property> GetDeclaredAttributes(Class cls)
extern function List<Property> GetOverridenProperties(Property prop)
extern function Property GetOpposite(Property property)
extern function List<Property> GetOpposites(Property property)

extern function List<Operation> GetDeclaredOperations(Class cls)
extern function List<Operation> GetOverridenOperations(Operation op)

extern function string GenerateDefaultValue(Property property)

extern function IEnumerable<string> CommentLines(string text, bool escapeHtml)


template GenerateInterface()
using MetaDslx.Modeling;
using System;
using System.Collections.Generic;
using System.Data;
using System.Text;

namespace MetaDslx.Languages.Uml.MetaModel
{
    ["["]MetaModel(Uri="http://www.omg.org/spec/UML/", Prefix="uml")["]"]
	public partial interface UmlMetaModel
	{
	}
^
	[loop(Instances->pt:typeof(PrimitiveType))]
    [GeneratePrimitiveType(pt)]
	[end loop]
	[loop(Instances->enm:typeof(Enumeration))]
^
    [GenerateEnum(enm)]
	[end loop]
	[loop(Instances->cls:typeof(Class))]
^
    [GenerateClass(cls, false)]
	[end loop]
}
end template

template GenerateImplementation()
using MetaDslx.Modeling;
using System;
using System.Collections.Generic;
using System.Data;
using System.Text;

namespace MetaDslx.Languages.Uml.MetaModel
{
	[loop(Instances->cls:typeof(Class))]
    [GenerateClass(cls, true)]
	[end loop]
}
end template

template GeneratePrimitiveType(PrimitiveType pt)
[GenerateComment(pt)]
const PrimitiveType [pt.Name];
end template

template GenerateEnum(Enumeration enm)
[GenerateComment(enm)]
public enum [enm.Name]
{
	[loop(enm->lit:OwnedLiteral; separator sep = ",")]
    [GenerateComment(lit)]
    [lit.Name.ToPascalCase()][sep]
	[end loop]
}
^
end template

template GenerateClass(Class cls, bool implementation)
[if (!implementation)]
[GenerateComment(cls)]
[cls.IsAbstract ? "[MetaClass(IsAbstract = true)]" : "[MetaClass]"]
public partial interface [cls.Name][GenerateBaseClasses(cls)]
[else]
public partial interface [cls.Name]
[end if]
{
	[loop(prop:GetDeclaredAttributes(cls))]
	[GenerateProperty(prop, implementation)]
	[end loop]
	[loop(op:GetDeclaredOperations(cls))]
	[GenerateOperation(op, implementation)]
	[end loop]
}
^
end template

template GenerateBaseClasses(Class cls)
[string sep = " : "]
[loop(cls->Generalization->gen:General)]
[sep][gen.Name]\
[sep = ", "]
[end loop]
end template

template GenerateProperty(Property prop, bool implementation)
[var overridenProps = GetOverridenProperties(prop)]
	[if (!implementation)]
		[loop (baseProp: overridenProps where baseProp.IsDerived && !baseProp.IsDerivedUnion)]
[GenerateType(baseProp, baseProp.Type)] [baseProp.Class.Name].[prop.Name.ToPascalCase()]
{
	get => this.[prop.Name.ToPascalCase()];
}
^
		[end loop]
	[end if]
[if ((implementation && prop.IsDerived && !prop.IsDerivedUnion) || (!implementation && (!prop.IsDerived || prop.IsDerivedUnion)))]
[GenerateComment(prop)]
[if (prop.Aggregation == AggregationKind.Composite)]
["["]Containment["]"]
[end if]
[if (prop.IsDerivedUnion)]
["["]DerivedUnion["]"]
[else if (prop.IsDerived)]
["["]Derived["]"]
[end if]
[if (prop.IsCollection() && !prop.IsUnique)]
["["]NonUnique["]"]
[end if]
[if (prop.IsCollection() && !prop.IsOrdered)]
["["]Unordered["]"]
[end if]
[if (prop.IsReadOnly)]
["["]ReadOnly["]"]
[end if]
[GenerateOpposite(prop)]
[GenerateRedefines(prop)]
[GenerateSubsets(prop)]
[if (prop.DefaultValue != null)]
["["]DefaultValue([prop.GenerateDefaultValue()])["]"]
[end if]
[if (prop.IsDerived && !prop.IsDerivedUnion)]
public [if (overridenProps.Count > 0)]new [end if][GenerateType(prop, prop.Type)] [prop.Name.ToPascalCase()]
{ 
	get
	{
		throw new NotImplementedException();
	}
}
[else]
[if (overridenProps.Count > 0)]new [end if][GenerateType(prop, prop.Type)] [prop.Name.ToPascalCase()] { get;[if (!prop.IsReadOnly && !prop.IsCollection())] set;[end if] }
[end if]
^
[end if]
end template

template GenerateType(MultiplicityElement me, MetaDslx.Languages.Uml.Model.Type t)
[me.IsCollection() ? "IList<" : ""][GeneratePrimitiveType(t)][me.IsCollection() ? ">" : ""]
end template

function string GeneratePrimitiveType(MetaDslx.Languages.Uml.Model.Type t)
	switch (t.Name)
		case "Boolean": return "bool";
		case "String": return "string";
		case "Integer": return "int";
		case "Real": return "double";
		case "UnlimitedNatural": return "long";
		default: return t.Name;
	end switch
end function

template GenerateRedefines(Property prop)
[loop(prop->rprop:RedefinedProperty)]
	[if (rprop.Class != null)]
["["]Redefines(typeof([rprop.Class.Name]), "[rprop.Name.ToPascalCase()]")["]"]
	[end if]
[end loop]
end template

template GenerateSubsets(Property prop)
[loop(prop->rprop:SubsettedProperty)]
	[if (rprop.Class != null)]
["["]Subsets(typeof([rprop.Class.Name]), "[rprop.Name.ToPascalCase()]")["]"]
	[end if]
[end loop]
end template

template GenerateOpposite(Property prop)
[var opposite = GetOpposite(prop)]
[if (opposite != null)]
["["]Opposite(typeof([(opposite.Class != null ? opposite.Class : prop.Type).Name]), "[opposite.Name.ToPascalCase()]")["]"]
[end if]
end template

template GenerateOperation(Operation op, bool implementation)
	[var overridenOps = GetOverridenOperations(op)]
	[var returnType = GenerateReturnType(op)]
	[if (implementation)]
[GenerateComment(op)]
public [if (overridenOps.Count > 0)]new [end if][returnType] [op.Name.ToPascalCase()]([GenerateParams(op)])
{
	throw new NotImplementedException();
}
^
	[else]
		[loop (baseOp: overridenOps)]
[GenerateReturnType(baseOp)] [baseOp.Class.Name].[op.Name.ToPascalCase()]([GenerateParams(op)])
{
	[if (returnType != "void")]return [end if]this.[op.Name.ToPascalCase()]([GenerateArguments(op)]);
}
^
		[end loop]
	[end if]
end template

template GenerateReturnType(Operation op)
[if (hasloop(op->param:OwnedParameter where param.Direction == ParameterDirectionKind.Return))]
	[loop(op->param:OwnedParameter where param.Direction == ParameterDirectionKind.Return)]
[GenerateType(param, param.Type)]
	[end loop]
[else]
void
[end if]
end template

template GenerateParams(Operation op)
[loop(op->param:OwnedParameter where param.Direction != ParameterDirectionKind.Return; separator sep = ", ")]
[GenerateType(param, param.Type)] [param.Name][sep]\
[end loop]
end template

template GenerateArguments(Operation op)
[loop(op->param:OwnedParameter where param.Direction != ParameterDirectionKind.Return; separator sep = ", ")]
[param.Name][sep]\
[end loop]
end template

template GenerateComment(Element elem)
[if (hasloop (elem->OwnedComment where !string.IsNullOrWhiteSpace(OwnedComment.Body)))]
/// <summary>
	[loop (elem->OwnedComment where !string.IsNullOrWhiteSpace(OwnedComment.Body))]
		[loop (line:CommentLines(OwnedComment.Body, true))]
/// [line]
		[end loop]
	[end loop]
/// </summary>
	[if (elem is Operation)]
		[loop (elem->typeof(Operation)->param:OwnedParameter->OwnedComment where !string.IsNullOrWhiteSpace(OwnedComment.Body))]
/// <param name="[param.Name]">
			[loop (line:CommentLines(OwnedComment.Body, true))]
/// [line]
			[end loop]
/// </param>
		[end loop]
	[end if]
[end if]
	[if (elem is Operation)]
[GenerateSpecification((Operation)elem)]
	[else if (elem is Property)]
		[var prop = (Property)elem]
		[if (prop.IsDerived && !prop.IsDerivedUnion)]
		[loop(prop->Class->op:OwnedOperation where op.Name == prop.Name)]
[GenerateSpecification(op)]
		[end loop]
		[end if]
	[end if]
end template

template GenerateSpecification(Namespace ns)
	[loop (ns->rule:OwnedRule->spec:Specification->expr:typeof(OpaqueExpression))]
		[loop (rule->OwnedComment where !string.IsNullOrWhiteSpace(OwnedComment.Body))]
/// <para>
			[loop (line:CommentLines(OwnedComment.Body, true))]
/// [line]
			[end loop]
/// </para>
		[end loop]
// [rule.Name]:
		[loop (expr->Body)]
			[loop (line:CommentLines(Body, false))]
//     [line]
			[end loop]
		[end loop]
	[end loop]
end template
